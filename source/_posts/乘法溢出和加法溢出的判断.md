title: 乘法溢出和加法溢出的判断
date: 2014-12-02 21:22:56
categories: CSAPP
tags: [os, csapp, 读书笔记]
description:
---

# 乘法溢出和加法溢出的判断
<br>

> 根据CSAPP中补码和无符号数计算章节的提炼

<br>
## 溢出的缘由
C语言当中的数据类型，有无符号整数，也有有符号的整数，有符号的整数通常在计算机中都是用补码来表示的。首先，计算机承认的数据类型只有一种，就是二进制串，那么，不管一个数最后被解释成是有符号数还是无符号数，那么这个数在内存中的位模式是不变的，所以两个不同或者相同的位模式相加的话，所得到的位模式也是不变的。这也就是为什么，对于无符号数和有符号数的计算都可以统一用一种规则。

对于无论是加法还是乘法这种算数运算来说，都存在着运算结构溢出这种现象的发生，什么叫溢出，如果我理解，就是我们算出来的数值结果，计算机已经不能够准确完全的表示了，如果出现计算结果的数据长度大于计算机的字长的话，那么就需要进行数据截断操作，一旦发生了截断操作，那么我们的真实结果就会发生变动，这种情况就是溢出。
<br>
## 无符号数加法的溢出
例如，一个四位的二进制串。如果现在一个无符号数1111+0111=10110。如果说现在计算机的子长只有4的话，那么肯定存不下这5位二进制的结果，这样就会截断溢出的那一位，编程0110.原来的无符号数的加法是15+7=22.四位二进制数的无符号数的取值范围为0~15.本来的真实结果是22，因为溢出的原因变成了6.我们发现，运算结果出来之后把最高位，也就是从右向左的第五位舍去了，那么这就在我们原来的运算结果中减掉了2^4.所以说结果从22变为了6。
<br>
这一个例子也就告诉了我们在计算机中，我们所做的无符号数的加法运算是模2^k的运算，其中k是计算机的机器字长。
<br>
## 判断无符号数的溢出
如果是无符号数的话。s=x+y，没有溢出时肯定是s>x+y。如果一旦有了溢出的话，那么x>s||y>s。
例如，如果计算溢出s=x+y-2^k,假设2^k>y，那么x+y-2^k<x，则s<x
<br>

## 补码加法的溢出
前面已经提到过，同一个二进制串可以被解释成一个补码一个无符号数。那么虽然我们看起来两者是由区别的，但是在位模式上，在针对位模式的运算上面，两者并没有什么不同，因为都是对同一个位模式进行操作，只不过最后可以被解释称无符号数和有符号数。

### 补码的运算规则
既然无符号数和补码都能够表示成同一个位模式的话，那么加法的运算规则也就比较统一-------在计算补码的加法的时候，例如：0111+1001，可以先把这两个位模式看成无符号数，根据无符号数的规则进行相加结果为10000，然后要进行截断操作结果为0000.最后把无符号数已经截断的运算结果解释称为补码（也就是从无符号数到有符号数的转换），就是补码运算最后的结果。

> 之所以可以这么做，就是使用了，两个数的w位的补码和无符号数可能有相同的位模式这一特点。

### 溢出
因为是有符号数，也就是补码，溢出的种类也分两种，正溢出和负溢出。
1. 正溢出，是因为计算的结果在未截断之前大于规定位数所能表示的最大值，在模2^k的时候，就要在原来的无符号数的结果上相应的减掉2^k。
2. 负溢出，是因为计算结果在未截断之前，小于我们所规定位数能够表示的最小值，在模2^k的时候就要相应的加上2^k。

总之，在处理正溢出还有负溢出的时候，都是想把超出我们能够表示的结果修正成我们能够表示的结果。

<br>

## 判断补码加法的溢出

有一些基本的运算常识我觉得都会对运算有以下几个认识：
1. 一个正数一个负数(前提是合法的),相加绝对不会出现溢出
2. 两个正数相加可能溢出最后得到0或者一个负数
3. 两个负数相加可能溢出最后得到一个正数

所以说，根据上面这些常识，我们完全就能够判断出补码的加法的溢出：
```c
flag1 = x<0&&y<0&&(x+y)>0;
flag2 = x>0&&y>0&&(x+y)<=0;
return !flag1&&(!flag2);
```
这个程序的道理很简单，都是计算的时候，我们理想的结果和我们实际的结果是不匹配的，仔细想想，两个正数相加最后得到0或者负数这明显不正常，肯定是计算之中出了问题么。
<br>

## 无符号数的乘法和有符号数的乘法

无符号数的乘法几乎和加法的处理办法一样，都是在算得结果之后，如果结果的长度超出计算机的字长，那么就进行模2^k的操作，即把结果“瘦身”，放进字节为2^k的空间内。有符号数的乘法运算也是仿照，有符号数的加法运算的处理办法一样，因为一个位模式可能会生成一个补码序列一个无符号数序列，两者可能在数值上是不同的，但是在位模式下是绝对相同的。利用这一特点，在计算补码乘法的时候，继续把这些位模式当作无符号数进行乘法运算，最后把进行截断操作的结果再解释为有符号数的补码。

> 比较重要的一点是，虽然补码和无符号数相乘的结果，在未截断之前的位模式可能是不一样的，但是一旦在规范之后，也就是在截断之后，两者的位模式是肯定会相同的。

比如，我的计算机字长有3位，要计算101和011的乘法：



| 种类           |乘数           | 被乘数 |未截断     |截断后 |
| -------------  |:-------------:|  -----:|-----:     |-----: |
| 有符号         | 101（5）      |011(3)  | 001111(15)|111(7) |
| 无符号         | 011(3)        | 011(3) |110111(-9）|111(-1)|


根据上面的例子可以看出有符号数相乘的结果和无符号数相乘的结果在截断后都是相同的，只不过是把位模式解释成了补码或者无符号数。并不要在意没有截断之前的位模式，因为真正在计算机中是不会出现这种位模式的中间计算结果的。

## 判断乘法溢出

判断乘法运算结果的溢出有两种办法，第一种是利用除法来判定，比较麻烦。还有一种比较简单。例如，如果两个w位的数相乘，那么结果最多占2w位。所以说，普通32位数的乘法，可以把两个乘数分别转换为64位的long long型来进行计算，这样的话，也只是对原来的数进行位扩展，所得的64位结果再转换为int类型，看和实际上两个32位乘数相乘计算（截断后）的结果是不是相同，如果相同，那么当然就是没有任何溢出。




