title: 多线程相关
date: 2014-12-22 14:59:56
categories: OS
tags: [os, 读书笔记]
description:
---


##进程的概念
<br>
计算机当中有程序，进程，线程这三个概念。程序是计算机指令集合以文件的形式存储在我们的硬盘上，比如我们长写的C语言控制台程序，最后生成的可执行文件.exe，这就是程序。
进程，是运行的程序，它是程序一个运行当中的实例。也就是说，一个程序可以对应与多个进程，可以对应于多个运行当中的程序实例。说白了：程序是死的，进程是活的。<br>
程序的运行，也就是进程的运行都需要一定的系统资源来进行支撑，因为程序在运行的时候总会用到各种各样的比如内存等系统资源，系统是把这些系统资源都分配给了进程，而不是分配给了程序。因此，进程是计算机中一个独立的运行单位。

<br>

## 进程的组成
<br>
进程有两部分：<br>
1. 内核对象部分: 计算机的内存都分为内核部分和用户部分。操作系统想管理进程，就必须要知道这个进程的一些参数和信息，所以在相应的内核部分要维护一个小的内存块，称为内核对象，这个对象是一个特殊的数据结构，里面存储了很多和进程相关的信息。(我认为这个内核对象就是进程控制块，PCB)<br>
2. 地址空间：里面存放了数据和代码已经所有分配的动态的内存空间等等。
<br>

## 进程的执行方式
<br>
关于进程，一直强调给自己的一点就是，进程虽然是计算机中资源分配和系统调度的单位，但是进程是不做一些实际性的工作的，进程的创建只不过是为我们提供一个大的好的执行环境，真正执行代码处理数据的，是进程里面的线程。每一个进程在创建的同时都会创建一个主线程，比如我们写控制台程序时候的main函数，都知道一个程序的开始是从main函数开始，但是执行这个main函数的不是进程本身，而是进程当中的主线程。当然，主线程就像是母细胞一样，可以创建出一些子线程，为整个进程分工而行。
<br>
## 进程的地址空间
<br>
进程是比较傻的，系统为每一个进程都分配一个虚拟的内存地址空间，让每一个进程都误以为他们是计算机当中唯一一个运行的进程。A进程访问的0x123456和B进程访问0x123456，两个进程访问的地方虽然表面上看起来是一样的，但是实际上访问的是两个地方。由于分配给进程的是虚拟地址空间，那么，真正在把数据要存储到物理介质上，还需要从虚拟地址空间到物理存储设备的一个映射。但是要注意，映射的物理存储的大小包括了两个部分，一个是真正的物理内存，还有一部分就是虚拟内存，虚拟内存就是在硬盘上开辟一些空间去弥补内存速度快容量小的优点。所以，对于一般的32位的机器来说，分配给一个进程的虚拟地址空间都是4GB(2^32).
<br>
## 线程的概念
<br>
对于线程来说，唯一要注意的就是，线程的一切活动都是在进程的地址空间中进行的。线程同样有两部分组成，一部分是内核对象，另外一部分是线程栈。PS：我还是觉得，书上说的这个所谓的内核对象其实就是线程控制块。线程栈，则是存放线程执行一些函数和代码所需要的参数和变量的地方，它主要存储在进程的地址空间内，因为进程主要就是为线程提供良好的运行环境的。并且，一个进程下面所属的线程彼此之间都是可见的，进程下面所有的线程都会对其他的线程或者说是进程控制块的一些句柄都能够正常的访问到。
<br>
## 线程的运行
<br>
线程的调度，用的是时间片轮转的办法，频繁的进行切换，让人们误以为所有的线程都是同时在运行的，实际上，对待单核的机器来说，多线程都是并发的在运行的。(请注意：并发和并行是有区别的)。我们都知道main函数是一个程序的主线程，那么当我们在创建新的子线程的时候，也需要为这个线程指定一个函数，以便这个线程在创建之后就直接执行这个函数，但是这个函数的定义是要符合一定的要求的。

一般来说，我们在创建一个新线程的时候，都是先用createthread函数先创建，之后，紧接着就用closehandle函数来关闭进程的句柄。原因是这样的，每一个线程的内核对象都有一个叫做引用计数的机制用于垃圾回收处理。当我们在创建一个新的子线程的时候，子线程在主线程中就有一个引用，此时，线程的引用计数就已经是1了，后来在线程的实际运行过程当中，引用计数还会加1，也就是说，如果我们确实对主线程对子线程的引用不感兴趣的话，最好是把它关闭，不然，当一个线程运行结束之后，虽然引用计数会减掉1，但是仍然没有减小到0，因为主线程还对子线程有着引用，所以，这个线程就只能到整个进程结束的时候才能够结束。
<br>

## 互斥对象
<br>
由于线程都是交替进行的，并且一个进程中的多个线程都在一段共同的地址空间内，这样一来，一些共享资源可能就会因为多个线程的访问而造成混乱，为了防止这种情况，操作系统将为每一个共享且一次只能有一个线程使用的资源定义一个互斥对象，这个互斥对象就相当于门一样，一次只放进一个线程进来访问门里面的共享资源，在有多余一个线程想要使用同一个资源的时候，就会把它挡在门外，不让其他线程进来。针对互斥对象来讲，就相当于我们在操作系统中，生产者和消费者算法里面的PV操作一样。每一个互斥对象都是一个内核对象，里面维护了三个比较重要的数据，线程ID,使用数量，计数器。其中ID是哪一个线程正在使用这个互斥对象，那么这个ID就是那个线程的ID，其次，计数器就相当于PV操作里面的信号量，只不过计数器里面的数都是>=0的数字。<br>
<br>
创建了互斥对象之后，接下来就是使用和释放互斥对象，这也就是PV操作的实质。每一个共享的资源，都应该有一个相对应的互斥对象来守卫着它。每一次，当一个线程想使用这个共享资源的时候，都需要先请求这个互斥对象，注意，互斥对象和共享资源都一样，一次只能被一个线程使用，只不过互斥对象相当于一个大门一样，一次只放进来一个线程，其余的线程虽然请求使用，但是都把他们租挡在门外，只不过会记下这些调用互斥对象的线程。<br>
具体使用的请求互斥对象的函数可能因为平台的不同而不同。当我们使用完共享资源的时候，我们也就应该释放对互斥对象的所有权，好让他放进新的线程进入共享资源的空间内进行使用。所以，在使用互斥对象保证共享资源的使用正确时，一般是这样的流程：创建互斥对象---》使用互斥对象——————》释放互斥对象。
<br>

## 多线程实例
结合多线程和网络变成，写了一个基于UDP协议的网络聊天室程序。<br>
[源码地址](https://github.com/fengzixu/MultiThreading-Chat-Programe)

