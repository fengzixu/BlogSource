{"Asset":[{"_id":"source\\CNAME","path":"CNAME","modified":false},{"_id":"source\\image\\a51.jpg","path":"image/a51.jpg","modified":false},{"_id":"source\\image\\des2.jpg","path":"image/des2.jpg","modified":false},{"_id":"source\\image\\des1.jpg","path":"image/des1.jpg","modified":false},{"_id":"source\\image\\des3.jpg","path":"image/des3.jpg","modified":false},{"_id":"source\\image\\des4.jpg","path":"image/des4.jpg","modified":false},{"_id":"themes\\jacman\\source\\js\\snowstorm-min.js","path":"js/snowstorm-min.js","modified":false},{"_id":"themes\\jacman\\source\\js\\jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":false},{"_id":"themes\\jacman\\source\\js\\totop.js","path":"js/totop.js","modified":false},{"_id":"themes\\jacman\\source\\img\\author.jpg","path":"img/author.jpg","modified":false},{"_id":"themes\\jacman\\source\\img\\favicon.ico","path":"img/favicon.ico","modified":false},{"_id":"themes\\jacman\\source\\img\\1.jpg","path":"img/1.jpg","modified":false},{"_id":"themes\\jacman\\source\\img\\f.png","path":"img/f.png","modified":false},{"_id":"themes\\jacman\\source\\img\\logo.png","path":"img/logo.png","modified":false},{"_id":"themes\\jacman\\source\\img\\jacman.jpg","path":"img/jacman.jpg","modified":false},{"_id":"themes\\jacman\\source\\img\\scrollup.png","path":"img/scrollup.png","modified":false},{"_id":"themes\\jacman\\source\\img\\logo.svg","path":"img/logo.svg","modified":false},{"_id":"themes\\jacman\\source\\font\\FontAwesome.otf","path":"font/FontAwesome.otf","modified":false},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":false},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":false},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":false},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":false},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":false},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":false},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":false},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":false},{"_id":"themes\\jacman\\source\\font\\fontdiao.eot","path":"font/fontdiao.eot","modified":false},{"_id":"themes\\jacman\\source\\font\\fontdiao.svg","path":"font/fontdiao.svg","modified":false},{"_id":"themes\\jacman\\source\\font\\fontdiao.woff","path":"font/fontdiao.woff","modified":false},{"_id":"themes\\jacman\\source\\font\\fontdiao.ttf","path":"font/fontdiao.ttf","modified":false},{"_id":"themes\\jacman\\source\\css\\style.styl","path":"css/style.styl","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\blank.gif","path":"fancybox/blank.gif","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":false},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":false}],"Cache":[{"_id":"scaffolds\\draft.md","mtime":1415513080000},{"_id":"scaffolds\\photo.md","mtime":1415513080000},{"_id":"scaffolds\\page.md","mtime":1415513080000},{"_id":"scaffolds\\post.md","mtime":1416330562000},{"_id":"source\\CNAME","mtime":1415516414000},{"_id":"source\\_posts\\DES与A5-1加密算法的解析.md","mtime":1420875693000},{"_id":"source\\_posts\\MFC的消息映射机制.md","mtime":1419898404000},{"_id":"source\\_posts\\Tcp运输连接的管理.md","mtime":1419898404000},{"_id":"source\\_posts\\Two-Years-With-You.md","mtime":1419898404000},{"_id":"source\\_posts\\自己实现和malloc有关的函数.md","mtime":1419898404000},{"_id":"source\\_posts\\乘法溢出和加法溢出的判断.md","mtime":1419898404000},{"_id":"source\\_posts\\进程的概念.md","mtime":1419898404000},{"_id":"source\\_posts\\初探Windows网络编程.md","mtime":1419898404000},{"_id":"source\\_posts\\重读CSAPP（第一章）.md","mtime":1419898404000},{"_id":"source\\about\\index.md","mtime":1415858778000},{"_id":"source\\image\\a51.jpg","mtime":1420874261000},{"_id":"source\\image\\des2.jpg","mtime":1420874294000},{"_id":"source\\image\\des1.jpg","mtime":1420874276000},{"_id":"source\\image\\des3.jpg","mtime":1420874299000},{"_id":"source\\image\\des4.jpg","mtime":1420874310000},{"_id":"themes\\jacman\\_config.yml","mtime":1421550017000},{"_id":"themes\\jacman\\README.md","mtime":1415531218000},{"_id":"themes\\jacman\\languages\\default.yml","mtime":1415531218000},{"_id":"themes\\jacman\\LICENSE","mtime":1415531218000},{"_id":"themes\\jacman\\languages\\zh-CN.yml","mtime":1415531218000},{"_id":"themes\\jacman\\languages\\zh-TW.yml","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\archive.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\scripts\\fancybox.js","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\category.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\index.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\layout.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\page.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\post.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\tag.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\blogroll.ejs","mtime":1415852488000},{"_id":"themes\\jacman\\layout\\_widget\\archive.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\category.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\links.ejs","mtime":1415851850000},{"_id":"themes\\jacman\\layout\\_widget\\rss.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\clock.ejs","mtime":1420988981000},{"_id":"themes\\jacman\\layout\\_widget\\tag.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\tagcloud.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_widget\\weibo.ejs","mtime":1415856800000},{"_id":"themes\\jacman\\layout\\_partial\\after_footer.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\article.ejs","mtime":1421549812000},{"_id":"themes\\jacman\\layout\\_partial\\article_row.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\archive.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\footer.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\categories.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\head.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\header.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\mathjax.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\google_analytics.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\pagination.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\search.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\sidebar.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\totop.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\tags.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\article.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\footer.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\catetags.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\gallery.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\comment.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\jiathis.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\header.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\layout\\_partial\\post\\pagination.ejs","mtime":1415531218000},{"_id":"themes\\jacman\\source\\js\\snowstorm-min.js","mtime":1421548838000},{"_id":"themes\\jacman\\source\\js\\jquery-2.0.3.min.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\js\\totop.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\img\\author.jpg","mtime":1415576750000},{"_id":"themes\\jacman\\source\\img\\favicon.ico","mtime":1415531218000},{"_id":"themes\\jacman\\source\\img\\1.jpg","mtime":1415576658000},{"_id":"themes\\jacman\\source\\img\\f.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\img\\logo.png","mtime":1415863834000},{"_id":"themes\\jacman\\source\\img\\jacman.jpg","mtime":1415531218000},{"_id":"themes\\jacman\\source\\img\\scrollup.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\img\\logo.svg","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\FontAwesome.otf","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.ttf","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.svg","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.svg","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.woff","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.ttf","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.woff","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\coveredbyyourgrace-webfont.eot","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontawesome-webfont.eot","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontdiao.eot","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontdiao.svg","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontdiao.woff","mtime":1415531218000},{"_id":"themes\\jacman\\source\\font\\fontdiao.ttf","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\style.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_base\\font.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_base\\code.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_base\\public.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_base\\variable.styl","mtime":1421550702000},{"_id":"themes\\jacman\\source\\css\\_partial\\article.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\aside.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\footer.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\duoshuo.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\helper.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\header.styl","mtime":1415864570000},{"_id":"themes\\jacman\\source\\css\\_partial\\gallery.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\totop.styl","mtime":1415531218000},{"_id":"themes\\jacman\\source\\css\\_partial\\index.styl","mtime":1415864298000},{"_id":"themes\\jacman\\source\\fancybox\\blank.gif","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_loading.gif","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_loading@2x.gif","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_overlay.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_sprite.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.css","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\fancybox_sprite@2x.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\jquery.fancybox.pack.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\fancybox_buttons.png","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-buttons.css","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-buttons.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-media.js","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-thumbs.css","mtime":1415531218000},{"_id":"themes\\jacman\\source\\fancybox\\helpers\\jquery.fancybox-thumbs.js","mtime":1415531218000}],"Category":[{"name":"密码学","_id":"fm1vot4vt8ms6x0u","posts":["dvw216okq8beg7sn"]},{"name":"Windows","_id":"8512ljrmz0he6ybp","posts":["sairt3q2rslnr26m","y07r9zu3zyje911n"]},{"name":"计算机网络","_id":"ofps7i7zi0zt6wuj","posts":["yzt8daaychd8puyu"]},{"name":"OS","_id":"1738y9s4gafvcrll","posts":["87y8rz2bi7woe2x4","v42oi49bn9bbqzi5"]},{"name":"Life","_id":"n0c0eng5c2ofedd0","posts":["00qaobvpvh6on9pr"]},{"name":"CSAPP","_id":"vui64jezcwp8fefa","posts":["0lgbbh81pebd64e5","4mq396sz07h2qgmp"]}],"Page":[{"title":"About","date":1415858759000,"content":"<h2 id=\"个人档案\">个人档案</h2>\n<p><br></p>\n<ul>\n<li>本体：徐冉</li>\n<li>分身：fengzi/疯子</li>\n<li>星座、血型：巨蟹，A</li>\n<li>来自：内蒙古</li>\n<li>多重身份：普通一本大学CS本科生一名，伪Acmer</li>\n<li>兴趣爱好：Linux，操作系统，各种通过不断琢磨思考才能够获得成果的知识。</li>\n<li>HATE:复制粘贴，欺骗自己</li>\n<li>愿望：能在毕业之前做一个自己的OS出来，甭管多丑，有用没用，就是为了圆自己一个梦</li>\n</ul>\n<p><br></p>\n<blockquote>\n<p><a href=\"http://blog.csdn.net/xr_acmer\" target=\"_blank\" rel=\"external\">CSDN</a><br><a href=\"https://github.com/fengzixu\" target=\"_blank\" rel=\"external\">GitHub</a><br><a href=\"http://www.renren.com/416799483\" target=\"_blank\" rel=\"external\">人人</a></p>\n</blockquote>\n","source":"about/index.md","raw":"title: About\ndate: 2014-11-13 14:05:59\n---\n## 个人档案\n<br/>\n- 本体：徐冉\n- 分身：fengzi/疯子\n- 星座、血型：巨蟹，A\n- 来自：内蒙古\n- 多重身份：普通一本大学CS本科生一名，伪Acmer\n- 兴趣爱好：Linux，操作系统，各种通过不断琢磨思考才能够获得成果的知识。\n- HATE:复制粘贴，欺骗自己\n- 愿望：能在毕业之前做一个自己的OS出来，甭管多丑，有用没用，就是为了圆自己一个梦\n\n<br/>\n> [CSDN](http://blog.csdn.net/xr_acmer)\n[GitHub](https://github.com/fengzixu)\n[人人](http://www.renren.com/416799483)\n\n","updated":1415858778000,"path":"about/index.html","excerpt":"","_id":"jnvu5hmjh4x4sa1a","comments":true,"layout":"page"}],"Post":[{"title":"DES与A5-1加密算法的解析","date":1420873903000,"categories":["fm1vot4vt8ms6x0u"],"tags":["uuyyus036pzw6j46"],"description":null,"content":"<h2 id=\"A5-1加密算法\">A5-1加密算法</h2>\n<ol>\n<li><p>基本原理<br>A5-1加密算法是一种流密码，通过密钥流对明文进行加密，然后用密钥流进行对密文的解密操作。<br>这种算法主要用于GSM加密，也就是我们平时打电话的时候，通信数据发送到基站，基站发送到另一个基站，基站发送到接收方。<br>每次通话的时候，基站会产生一个64位的随机数，与我们手机sim卡内本身带的一个密码利用一种加密算法生成一个密钥，这个密钥就是这次通话过程中使用的主密钥，此密钥的生命周期为这一次通话的开始到结束。一旦通话完成，那么这个密钥也就没有用了。<br>该加密算法把整个通讯的数据划分为每一帧来进行加密。每一帧是有228位，其中发送端给接收端的数据114位，接收端反馈给发送端的数据有114位。除了上面提出的基站给出的64的总密钥，针对每一帧的加密，还有一种叫做会话密钥，这种会话密钥每加密一帧都会改变，会话密钥的生成是由帧号来决定的。每一次的会话密钥都会产生一个228位的乱数来加密这一帧的数据。加密的方式是异或。帧号一共用22位的二进制数来表示，也就是说一次通话只能传递2^22次方的通讯数据，因为每一次通话只有这么多帧可以进行加密数据并且传递。<br>A5-1算法基于三个线性移位反馈寄存器实现的。三个LFSR的级数分别是19 22 23。<br>f1(x) = x^19 + x^18 + x^17 + x^14 + 1<br>f2(x) = x^22 + x^21 + 1<br>f3(x) = x^23 + x^22 + x^21 + x^8 + 1<br>三个反馈多项式如上所示。</p>\n</li>\n<li><p>所用工具<br>根据上面所讲的，我们基本可以确定，如果要实现a5-1的加密算法，我们需要哪些工具：<br>首先是明文，其次是64位的密钥，三个LFSR，以及帧号。<br>算法的输入应该就是三个LFSR的初始值，算法的输出就是我们加密明文所需要的乱数。</p>\n</li>\n<li><p>实现步骤<br>算法总体来说分为三个部分，初始化，运算，输出乱数<br>A5-1加密算法实现的逻辑结构图如下：<br><img src=\"/image/a51.jpg\" alt=\"\"><br>首先是初始化部分：<br>（1）将三个寄存器内的所有位全都赋值为0<br>（2）将三个寄存器做64次的移位操作，每第i次操作，寄存器的反馈内容都先与密钥中的第i位进行异或，然后把这样异或的结果作为寄存器此次的反馈内容。三个LSFR都要并行的做这样的工作64次。<br>（2）将三个寄存器做22次的移位操作，没第i次操作，寄存器的反馈项都先与帧序号的第i位进行异或，将异或的结果作为寄存器的最终反馈内容，同样，三个LSFR也都要并行做22次。<br>上述三步昨晚，A5-1加密算法的初始化操作也就做完了。另外需要注意的是，A5-1加密算法的LSFR是左移操作，并且，密钥和帧号都是从最低位到最高位编号。<br>当初始化步骤完成的时候，此时三个LSFR的状态合称为S0状态。<br>接下来是计算和输出部分：<br>大家可以看到，上面的逻辑结构图中，有一个叫做钟控的部分，他有三个输出三个输入，三个输入是分别来三个LSFR的某一个固定位，输入会输出0或者1.0表示此次这个LSFR不会工作，也就是不会发生移动等等，输出的是1的话，那么这个LSFR此次就会移动一位并且得出反馈的结果。也就是说这个钟控在控制着三个LSFR的工作与否。<br>首先根据钟控的方式三个LSFR连续移动100次，但是不输出乱数，此时应该只是做一个混乱的操作。因为LSFR在移动过程中，每一位寄存器内的数值都会不一样，所以在钟控决定每个寄存器运行与否的结果时也会不相同。<br>接下来会三个LSFR会接着进行连续的114次的移动，也是根据钟控的方式。这一次的移动过程中，三个寄存器将分别把最高位寄存器的值输出，然后三个值做异或运算，形成第i个乱数。这次114次移动会生成一个114位的乱数，用于对手机到基站这一段的数据加密。<br>之后再进行一次100次的移动和114次的移动，结果和上面说的相同，最终产生的114位密钥用于基站到手机这段的通讯数据加密。<br>关于钟控：<br>钟控将第一个寄存器的第八位，第二个寄存器的第10位，第三个寄存器的第10位。抽取这三个位用于控制三个LSFR的动作与否。他们决定的原则类似少数服从多数，三位一共有8中排列方式，当三位中1的个数多余0的个数时，那么这三位是1的对应的寄存器将会移动， 为0的不会，如果三位数中0的个数多余1的个数时，那么三位之中是0的对应的寄存器将会移动。<br>根据上面的步骤就可以算出当我们把通讯数据切割成每一帧，然后对每一帧进行加密传输的时候，所需要的那个加密的乱数是怎么得来的。至于加密过程很简单，就是明文和乱数的异或操作。</p>\n</li>\n</ol>\n<h2 id=\"DES加密算法\">DES加密算法</h2>\n<p>如果说A5-1是流密码的加密算法的话，那么DES就是分组密码体制中典型的一个算法。分组密码的主要思想，就是把明文和密钥都分成一定长度的许多断数据，为了保证每一个明文都仅仅只有一个密钥，需要做的就是分组的密钥长度要大于等于分组的明文长度。通过分组加密，每一组使用的密钥都不相同，这就是基本的分组密码。</p>\n<p>分组密码的安全性除了收到一些密钥长度参数的影响之外，最重要的两个原则就是混乱原则和扩散原则。<br>混乱原则要求明文和密文在逻辑上的关系越复杂越好。为了保证混乱原则的实行，我们将尽可能使用非线性的变换。<br>扩散原则，我理解是这样的，在设计密码的时候，通过实行混乱原则，使得我们的密码会在整个序列的某基础发生混乱，那么扩散原则要做的，就是要通过移位的方式，将这种混乱最大化，让明文和密钥的变化尽可能多的影响密文的生成。这种思想最典型的体现，就是S-P网络。</p>\n<p>分组密码中的一个很典型的例子就是DES算法：<br>DES算法也是分组密码的一个案例，它属于分组密码中的迭代分组密码，即用简单的加密措施先构造出一个加密函数来，之后不断的进行乘积迭代，两个简单的方式乘积在一起的话，会形成一个更加复杂的密码函数，DES正式利用这样的思想来实现。</p>\n<p>DES加密算法的实现需要几个工具：<br>1.分组长度2.密钥长度3.迭代次数4.子密钥长度<br>DES默认分组长度为64bit,密钥长度也是64bit,迭代次数为16，子密钥的长度为48位<br>DES加密算法的输入是一组64bit的明文，输出是64bit的密文<br>算法执行过程中有3步：初始变换， 16轮迭代， 初始逆变换<br>要注意的是，DES的算法中的比特序号是从1开始.<br><img src=\"/image/des1.jpg\" alt=\"\"></p>\n<ol>\n<li><p>DES算法中的初始变换：<br>初始变化实际上就是对明文序列进行顺序打乱操作。他会按照一个特定的表格进行对照移动。<br>初始逆置换是对16次迭代后的结果序列进行移位操作，也是有一个对照表，告诉你移动的规则。</p>\n</li>\n<li><p>DES算法中的圈函数：<br>从上面的DES算法的逻辑结构图中可以看出，他李永乐Feistel模型进行迭代密码的实现。那么这个迭代有一个圈函数<br>Li = Ri-1  Ri = Li-1^f(Ri-1, ki)(i = 1, 2, …)<br>在进行完初始置换之后，我们得到一个长度为2w的序列，也就是64位的明文序列。把他们一分为二，分为左半部分和右半部分，在进行第一次迭代的时候，右半部分变为下一次迭代的左半部分，左半部分与F函数的结果进行按位异或形成下一轮迭代的右半部分。最后在迭代到第16次的时候，不在进行这样的左右交换操作，直接转换为对应的部分。<br>那么很显然，整个算法的核心就在于F函数的内容</p>\n</li>\n<li>F函数：<br>F函数的输入有两部分，一个是这一轮的子密钥48bit，另外一个是序列的右半部分的32bit。<br>F(R,K) = P(S(E(Ri)^Ki))<br>上述表达式告诉我们F函数一共有四个步骤，先是对R进行E盒的变换，E盒又称为是扩展变换盒</li>\n</ol>\n<ul>\n<li><p>E盒<br>E盒的作用就是把32位的数据扩展称为48位的数据，我觉得是因为密钥是48位，所以必须要扩展一下要变换的明文序列，因为分组密码的加密原则强调过，分组密码的加密，密钥是必须大于等于要加密的明文的。把32位的序列分成8组，每组序列在开头和结尾处分别添加开头和结尾元素相邻的元素，每一组添加2位，一共八组，田间16位，即扩展为48位，这是一种非线性的扩展。然后接下来就是与这一轮的子密钥Ki进行按位异或操作。</p>\n</li>\n<li><p>S盒<br>S盒宏观上的一个作用，是把刚刚异或生成的48位结果变换成32位。首先把48位的生成结果分成8组，每组6位。每6位分别作为S盒的输入，这样一共有8个S盒并行工作，将6位输入变为4位输出，最终得到32位的结果。<br>对于每一个S盒来说，有a1~~~a6的二进制比特输入，有这样的一个表格存在：<br><img src=\"/image/des2.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<p>现在S盒一共有6位的输入，a0a1a2a3a4a5a6<br>我现在算的是S1盒的输出，首先计算2a1+a6最后的十进制结果是多少，这个结果代表了行数。<br>之后计算8a2+4a3+2a4+a5最后的十进制结果代表了列数，拿到行数和列数之后，在表格中找到对应的数字，这里注意，如果我算出来的是1 3，那么我在找的时候，也是找表格中对应的标号是1行3列的元素，因为我们可以看到表格中的标号是从0开始的。<br>例如，如果计算的s1，得出的结果是1行3列，那么结果应该是4.查表得到这个结果之后，表格可以保证，得出的结果4位二进制数十完全可以表示的，所以将这个十进制数化为4位二进制数就完成了S盒的一部分操作，之后每一个S盒都按照这样的原则操作，之前异或的48位结果就会顺利的变成32位。</p>\n<ul>\n<li>P盒<br>P盒也是非常简单，就是根据一个表格进行一个移位操作，表格到时候会具体给出。</li>\n</ul>\n<p>经过上述的计算，我们可以顺利的得到F函数的计算结果。F函数的计算过程图如下：<br><img src=\"/image/des3.jpg\" alt=\"\"><br>经过上述的计算我们可以准确的得到F函数的具体结果，那么下轮迭代的右半部分也就是R1就可以由上一层的左半部分和F函数的结果异或得到。不知道为什么的，可以翻上去看一下DES实现的逻辑框图。<br>DES的算法基本执行流程就是这样的，那么还有一个问题可能我们没有考虑到，我们拥有的是一个64位的初始密钥，那么每一次的子密钥是怎么生成的呢？</p>\n<h2 id=\"DES子密钥的生成：\">DES子密钥的生成：</h2>\n<p>DES的初始密钥一共有64位，其中密钥的每一个字节的最后一位都用作奇偶校验，所以说，实际的有效密钥长度为56位。<br>DES子密钥的生成逻辑框图如下：<br><img src=\"/image/des4.jpg\" alt=\"\"></p>\n<ul>\n<li>首先，64位的初始密钥进来，最先要执行的就是置换选择操作1.<br>那么置换选择操作具体的内容是什么呢：<br>置换选择操作1有两个步骤：<br>（1）将64位中每一个密钥字节的最后一位丢弃<br>（2）将剩余的56位按照表格的规则打乱顺序，生成一个乱序的56位序列</li>\n<li>之后将输出的56比特的有效密钥序列一分为二，分为D0和C0两部分（生成C0D0到此为止只能算是密钥生成算法的初始化操作,不能算作一次迭代）。之后从第一次开始的每一次的迭代中，分别要对上一次的Di-1 Ci-1两部分进行循环左移操作，循环左移的次数和所在的迭代次数有关，比如D0C0—-&gt;D1C1是第一次迭代要循环左移1位，D2C2—-&gt;D3C2要左移2两位,具体的移位次数会有个明确的表格告诉大家。<br>每一次迭代的循环移位操作之后得到的两部分DiCi，将进行置换选择2的操作，置换选择2与1类似，都是打乱顺序，丢掉一部分元素，最后形成一个48位的序列，就是上面DES算法中第i次迭代所需要的子密钥。但是本次迭代生成的Di和Ci不会改变，因为他们将会用于下一次子密钥的生成操作。由于DES需要16次的迭代，那么子密钥的生成自然也需要16轮的迭代。</li>\n</ul>\n<p>也就是说，什么样算一次迭代操作呢，从循环位移，一直到置换选择2，再到最终生成第i次的子密钥ki算作是一次迭代，之前生成d0c0的部分不算。</p>\n","source":"_posts/DES与A5-1加密算法的解析.md","raw":"title: DES与A5-1加密算法的解析\ndate: 2015-01-10 15:11:43\ncategories: 密码学\ntags: 读书笔记\ndescription:\n---\n\n## A5-1加密算法\n1. 基本原理\nA5-1加密算法是一种流密码，通过密钥流对明文进行加密，然后用密钥流进行对密文的解密操作。\n这种算法主要用于GSM加密，也就是我们平时打电话的时候，通信数据发送到基站，基站发送到另一个基站，基站发送到接收方。\n每次通话的时候，基站会产生一个64位的随机数，与我们手机sim卡内本身带的一个密码利用一种加密算法生成一个密钥，这个密钥就是这次通话过程中使用的主密钥，此密钥的生命周期为这一次通话的开始到结束。一旦通话完成，那么这个密钥也就没有用了。\n该加密算法把整个通讯的数据划分为每一帧来进行加密。每一帧是有228位，其中发送端给接收端的数据114位，接收端反馈给发送端的数据有114位。除了上面提出的基站给出的64的总密钥，针对每一帧的加密，还有一种叫做会话密钥，这种会话密钥每加密一帧都会改变，会话密钥的生成是由帧号来决定的。每一次的会话密钥都会产生一个228位的乱数来加密这一帧的数据。加密的方式是异或。帧号一共用22位的二进制数来表示，也就是说一次通话只能传递2^22次方的通讯数据，因为每一次通话只有这么多帧可以进行加密数据并且传递。\nA5-1算法基于三个线性移位反馈寄存器实现的。三个LFSR的级数分别是19 22 23。\nf1(x) = x^19 + x^18 + x^17 + x^14 + 1\nf2(x) = x^22 + x^21 + 1\nf3(x) = x^23 + x^22 + x^21 + x^8 + 1\n三个反馈多项式如上所示。\n\n2. 所用工具\n根据上面所讲的，我们基本可以确定，如果要实现a5-1的加密算法，我们需要哪些工具：\n首先是明文，其次是64位的密钥，三个LFSR，以及帧号。\n算法的输入应该就是三个LFSR的初始值，算法的输出就是我们加密明文所需要的乱数。\n\n3. 实现步骤\n算法总体来说分为三个部分，初始化，运算，输出乱数\nA5-1加密算法实现的逻辑结构图如下：\n![](/image/a51.jpg)\n首先是初始化部分：\n（1）将三个寄存器内的所有位全都赋值为0\n（2）将三个寄存器做64次的移位操作，每第i次操作，寄存器的反馈内容都先与密钥中的第i位进行异或，然后把这样异或的结果作为寄存器此次的反馈内容。三个LSFR都要并行的做这样的工作64次。\n（2）将三个寄存器做22次的移位操作，没第i次操作，寄存器的反馈项都先与帧序号的第i位进行异或，将异或的结果作为寄存器的最终反馈内容，同样，三个LSFR也都要并行做22次。\n上述三步昨晚，A5-1加密算法的初始化操作也就做完了。另外需要注意的是，A5-1加密算法的LSFR是左移操作，并且，密钥和帧号都是从最低位到最高位编号。\n当初始化步骤完成的时候，此时三个LSFR的状态合称为S0状态。\n接下来是计算和输出部分：\n大家可以看到，上面的逻辑结构图中，有一个叫做钟控的部分，他有三个输出三个输入，三个输入是分别来三个LSFR的某一个固定位，输入会输出0或者1.0表示此次这个LSFR不会工作，也就是不会发生移动等等，输出的是1的话，那么这个LSFR此次就会移动一位并且得出反馈的结果。也就是说这个钟控在控制着三个LSFR的工作与否。\n首先根据钟控的方式三个LSFR连续移动100次，但是不输出乱数，此时应该只是做一个混乱的操作。因为LSFR在移动过程中，每一位寄存器内的数值都会不一样，所以在钟控决定每个寄存器运行与否的结果时也会不相同。\n接下来会三个LSFR会接着进行连续的114次的移动，也是根据钟控的方式。这一次的移动过程中，三个寄存器将分别把最高位寄存器的值输出，然后三个值做异或运算，形成第i个乱数。这次114次移动会生成一个114位的乱数，用于对手机到基站这一段的数据加密。\n之后再进行一次100次的移动和114次的移动，结果和上面说的相同，最终产生的114位密钥用于基站到手机这段的通讯数据加密。\n关于钟控：\n钟控将第一个寄存器的第八位，第二个寄存器的第10位，第三个寄存器的第10位。抽取这三个位用于控制三个LSFR的动作与否。他们决定的原则类似少数服从多数，三位一共有8中排列方式，当三位中1的个数多余0的个数时，那么这三位是1的对应的寄存器将会移动， 为0的不会，如果三位数中0的个数多余1的个数时，那么三位之中是0的对应的寄存器将会移动。\n根据上面的步骤就可以算出当我们把通讯数据切割成每一帧，然后对每一帧进行加密传输的时候，所需要的那个加密的乱数是怎么得来的。至于加密过程很简单，就是明文和乱数的异或操作。\n\n\n## DES加密算法\n如果说A5-1是流密码的加密算法的话，那么DES就是分组密码体制中典型的一个算法。分组密码的主要思想，就是把明文和密钥都分成一定长度的许多断数据，为了保证每一个明文都仅仅只有一个密钥，需要做的就是分组的密钥长度要大于等于分组的明文长度。通过分组加密，每一组使用的密钥都不相同，这就是基本的分组密码。\n\n分组密码的安全性除了收到一些密钥长度参数的影响之外，最重要的两个原则就是混乱原则和扩散原则。\n混乱原则要求明文和密文在逻辑上的关系越复杂越好。为了保证混乱原则的实行，我们将尽可能使用非线性的变换。\n扩散原则，我理解是这样的，在设计密码的时候，通过实行混乱原则，使得我们的密码会在整个序列的某基础发生混乱，那么扩散原则要做的，就是要通过移位的方式，将这种混乱最大化，让明文和密钥的变化尽可能多的影响密文的生成。这种思想最典型的体现，就是S-P网络。\n\n分组密码中的一个很典型的例子就是DES算法：\nDES算法也是分组密码的一个案例，它属于分组密码中的迭代分组密码，即用简单的加密措施先构造出一个加密函数来，之后不断的进行乘积迭代，两个简单的方式乘积在一起的话，会形成一个更加复杂的密码函数，DES正式利用这样的思想来实现。\n\nDES加密算法的实现需要几个工具：\n1.分组长度2.密钥长度3.迭代次数4.子密钥长度\nDES默认分组长度为64bit,密钥长度也是64bit,迭代次数为16，子密钥的长度为48位\nDES加密算法的输入是一组64bit的明文，输出是64bit的密文\n算法执行过程中有3步：初始变换， 16轮迭代， 初始逆变换\n要注意的是，DES的算法中的比特序号是从1开始.\n![](/image/des1.jpg)\n\n1. DES算法中的初始变换：\n初始变化实际上就是对明文序列进行顺序打乱操作。他会按照一个特定的表格进行对照移动。\n初始逆置换是对16次迭代后的结果序列进行移位操作，也是有一个对照表，告诉你移动的规则。\n\n2. DES算法中的圈函数：\n从上面的DES算法的逻辑结构图中可以看出，他李永乐Feistel模型进行迭代密码的实现。那么这个迭代有一个圈函数\nLi = Ri-1  Ri = Li-1^f(Ri-1, ki)(i = 1, 2, ...)\n在进行完初始置换之后，我们得到一个长度为2w的序列，也就是64位的明文序列。把他们一分为二，分为左半部分和右半部分，在进行第一次迭代的时候，右半部分变为下一次迭代的左半部分，左半部分与F函数的结果进行按位异或形成下一轮迭代的右半部分。最后在迭代到第16次的时候，不在进行这样的左右交换操作，直接转换为对应的部分。\n那么很显然，整个算法的核心就在于F函数的内容\n3. F函数：\nF函数的输入有两部分，一个是这一轮的子密钥48bit，另外一个是序列的右半部分的32bit。\nF(R,K) = P(S(E(Ri)^Ki))\n上述表达式告诉我们F函数一共有四个步骤，先是对R进行E盒的变换，E盒又称为是扩展变换盒\n\n\n- E盒\nE盒的作用就是把32位的数据扩展称为48位的数据，我觉得是因为密钥是48位，所以必须要扩展一下要变换的明文序列，因为分组密码的加密原则强调过，分组密码的加密，密钥是必须大于等于要加密的明文的。把32位的序列分成8组，每组序列在开头和结尾处分别添加开头和结尾元素相邻的元素，每一组添加2位，一共八组，田间16位，即扩展为48位，这是一种非线性的扩展。然后接下来就是与这一轮的子密钥Ki进行按位异或操作。\n\n- S盒\nS盒宏观上的一个作用，是把刚刚异或生成的48位结果变换成32位。首先把48位的生成结果分成8组，每组6位。每6位分别作为S盒的输入，这样一共有8个S盒并行工作，将6位输入变为4位输出，最终得到32位的结果。\n对于每一个S盒来说，有a1~~~a6的二进制比特输入，有这样的一个表格存在：\n![](/image/des2.jpg)\n\n现在S盒一共有6位的输入，a0a1a2a3a4a5a6\n我现在算的是S1盒的输出，首先计算2a1+a6最后的十进制结果是多少，这个结果代表了行数。\n之后计算8a2+4a3+2a4+a5最后的十进制结果代表了列数，拿到行数和列数之后，在表格中找到对应的数字，这里注意，如果我算出来的是1 3，那么我在找的时候，也是找表格中对应的标号是1行3列的元素，因为我们可以看到表格中的标号是从0开始的。\n例如，如果计算的s1，得出的结果是1行3列，那么结果应该是4.查表得到这个结果之后，表格可以保证，得出的结果4位二进制数十完全可以表示的，所以将这个十进制数化为4位二进制数就完成了S盒的一部分操作，之后每一个S盒都按照这样的原则操作，之前异或的48位结果就会顺利的变成32位。\n\n- P盒\nP盒也是非常简单，就是根据一个表格进行一个移位操作，表格到时候会具体给出。\n\n经过上述的计算，我们可以顺利的得到F函数的计算结果。F函数的计算过程图如下：\n![](/image/des3.jpg)\n经过上述的计算我们可以准确的得到F函数的具体结果，那么下轮迭代的右半部分也就是R1就可以由上一层的左半部分和F函数的结果异或得到。不知道为什么的，可以翻上去看一下DES实现的逻辑框图。\nDES的算法基本执行流程就是这样的，那么还有一个问题可能我们没有考虑到，我们拥有的是一个64位的初始密钥，那么每一次的子密钥是怎么生成的呢？\n\n## DES子密钥的生成：\nDES的初始密钥一共有64位，其中密钥的每一个字节的最后一位都用作奇偶校验，所以说，实际的有效密钥长度为56位。\nDES子密钥的生成逻辑框图如下：\n![](/image/des4.jpg)\n\n\n\n- 首先，64位的初始密钥进来，最先要执行的就是置换选择操作1.\n那么置换选择操作具体的内容是什么呢：\n置换选择操作1有两个步骤：\n（1）将64位中每一个密钥字节的最后一位丢弃\n（2）将剩余的56位按照表格的规则打乱顺序，生成一个乱序的56位序列\n- 之后将输出的56比特的有效密钥序列一分为二，分为D0和C0两部分（生成C0D0到此为止只能算是密钥生成算法的初始化操作,不能算作一次迭代）。之后从第一次开始的每一次的迭代中，分别要对上一次的Di-1 Ci-1两部分进行循环左移操作，循环左移的次数和所在的迭代次数有关，比如D0C0--->D1C1是第一次迭代要循环左移1位，D2C2--->D3C2要左移2两位,具体的移位次数会有个明确的表格告诉大家。\n每一次迭代的循环移位操作之后得到的两部分DiCi，将进行置换选择2的操作，置换选择2与1类似，都是打乱顺序，丢掉一部分元素，最后形成一个48位的序列，就是上面DES算法中第i次迭代所需要的子密钥。但是本次迭代生成的Di和Ci不会改变，因为他们将会用于下一次子密钥的生成操作。由于DES需要16次的迭代，那么子密钥的生成自然也需要16轮的迭代。\n\n也就是说，什么样算一次迭代操作呢，从循环位移，一直到置换选择2，再到最终生成第i次的子密钥ki算作是一次迭代，之前生成d0c0的部分不算。","slug":"DES与A5-1加密算法的解析","updated":1420875693000,"excerpt":"","_id":"dvw216okq8beg7sn","comments":true,"layout":"post","photos":[],"link":""},{"title":"MFC的消息映射机制","date":1419472525000,"categories":["8512ljrmz0he6ybp"],"tags":["uuyyus036pzw6j46"],"description":null,"content":"<blockquote>\n<p>windows是利用消息机来进行通信的，在SDK下面的消息映射机制和MFC下面的稍有不同。这里只介绍MFC的消息映射机制。此文和晚些POST上的关于多线程的一篇文章里面的一个聊天室的项目相关联。</p>\n</blockquote>\n<h2 id=\"消息传递和执行的准备工作\">消息传递和执行的准备工作</h2>\n<p>对于MFC中的消息传递，不需要像SDK下那样复杂的步骤，总体来讲只有三点：<br></p>\n<ol>\n<li>对应类中头文件的消息响应函数的声明<br></li>\n<li>对应类源文件中的消息映射宏<br></li>\n<li>对应类源文件中的消息响应函数的具体实现</li>\n</ol>\n<p>可以这么说，MFC的消息映射机制，都是基于这三步互相关联而来的。</p>\n<h2 id=\"消息响应函数的声明\">消息响应函数的声明</h2>\n<p>想处理一个消息必然要有相应的响应函数来处理。那么要在对应类中的头文件里面进行声明这个函数。声明这个函数和一般的函数不太相同。如果是我们自定义的消息，自定义这个消息对应的响应函数的话，那么我们可以以这种形式来声明这个消息响应函数。<br></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//{{AFX_MSG(对应类)</span></div><div class=\"line\">afx_msg <span class=\"keyword\">void</span> OnLButtonDown(UNIT nFlags, CPoint point); <span class=\"comment\">//消息响应函数</span></div><div class=\"line\"><span class=\"comment\">//AFX_MSG</span></div><div class=\"line\">DECLARE_MESSAGE_MAP()</div></pre></td></tr></table></figure>\n\n<p>可以看出函数限定符是afx_msg表明这是一个消息响应函数，他夹在两个AFX_MSG注释宏中间，即使自定义多个消息响应函数，他们的声明可以都放在这两个注释宏中间，这是整个类里面，消息响应函数声明的地方。<br><br></p>\n<h2 id=\"消息映射宏\">消息映射宏</h2>\n<p>在类的源文件中，还要添加响应的消息宏，他和消息响应函数将会被关联起来。消息映射宏存在放一个叫做消息映射表的结构里面。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">BEGIN MESSAGE_MAP(类名，CView)    <span class=\"comment\">//消息映射表的起点</span></div><div class=\"line\"><span class=\"comment\">//{{AFX_MSG_MAP(对应类)</span></div><div class=\"line\"><span class=\"comment\">//具体的消息映射宏</span></div><div class=\"line\"><span class=\"comment\">//AFX_MSG_MAP</span></div><div class=\"line\">...</div><div class=\"line\">END_MESSAGE_MAP()\t\t\t\t\t<span class=\"comment\">//消息映射表的终点</span></div></pre></td></tr></table></figure>\n\n<p><br></p>\n<h2 id=\"消息响应函数\">消息响应函数</h2>\n<p>根据前面的函数声明，在函数类的源文件中实现消息响应函数。由此可知，在MFC消息传递的过程当中，程序中出现和消息传递相关的就只有三处：消息响应函数的声明，消息映射表以及消息响应函数的具体定义。<br><br></p>\n<h2 id=\"消息机制实现过程\">消息机制实现过程</h2>\n<p>在每一个能够接受和发送消息的类中，都会创建一个消息，一个消息映射表，一个消息响应函数的声明和具体的定义。当有消息处理的时候，我们就要在消息映射表中查找看类能不能处理这个消息，消息映射表中，消息的类型和处理消息的函数地址都是一一对应的，如果能够处理这类消息，我们就要查找看是否有处理这个消息的具体方法函数。如果有的话就会执行。<br><br><br>实际上在实现的过程中，在执行我们自己创建的三部分之前，还要有一系列的步骤。MFC中任何一个消息都是和窗口相关联的，每一个窗口的句柄都会和当前类对象的一个指针进行关联，当出现一个消息的时候，我们就能够通过消息携带的一些参数找出这个消息和哪一个窗口句柄相关，然后找到他相对应的类对象指针，把这个类对象的指针，传递给这个窗口类的基类，基类中会调用一个windowproc的函数，这个函数内部会执行一个叫做OnWndMsg的函数，这个函数是真正的消息映射函数。因为传递给windowproc函数的是窗口类对象的指针，所以在OnWndMsg函数内，我们可以查找，窗口类头文件中是否有所需要的响应函数声明，然后再去查看消息映射表，看是否有相应的函数映射宏。如果上述步骤都成功执行，那么，就会顺利的调用消息响应函数来处理这个消息。</p>\n","source":"_posts/MFC的消息映射机制.md","raw":"title: MFC的消息映射机制\ndate: 2014-12-25 09:55:25\ncategories: [Windows]\ntags: 读书笔记\ndescription:\n---\n\n> windows是利用消息机来进行通信的，在SDK下面的消息映射机制和MFC下面的稍有不同。这里只介绍MFC的消息映射机制。此文和晚些POST上的关于多线程的一篇文章里面的一个聊天室的项目相关联。\n\n## 消息传递和执行的准备工作\n对于MFC中的消息传递，不需要像SDK下那样复杂的步骤，总体来讲只有三点：<br>\n1. 对应类中头文件的消息响应函数的声明<br>\n2. 对应类源文件中的消息映射宏<br>\n3. 对应类源文件中的消息响应函数的具体实现\n\n可以这么说，MFC的消息映射机制，都是基于这三步互相关联而来的。\n\n## 消息响应函数的声明\n想处理一个消息必然要有相应的响应函数来处理。那么要在对应类中的头文件里面进行声明这个函数。声明这个函数和一般的函数不太相同。如果是我们自定义的消息，自定义这个消息对应的响应函数的话，那么我们可以以这种形式来声明这个消息响应函数。<br>\n\t\n```c++\n\t\n\t//{{AFX_MSG(对应类)\n\tafx_msg void OnLButtonDown(UNIT nFlags, CPoint point); //消息响应函数\n\t//AFX_MSG\n\tDECLARE_MESSAGE_MAP()\n\n```\n可以看出函数限定符是afx_msg表明这是一个消息响应函数，他夹在两个AFX_MSG注释宏中间，即使自定义多个消息响应函数，他们的声明可以都放在这两个注释宏中间，这是整个类里面，消息响应函数声明的地方。\n<br>\n## 消息映射宏\n在类的源文件中，还要添加响应的消息宏，他和消息响应函数将会被关联起来。消息映射宏存在放一个叫做消息映射表的结构里面。\n\n```c\n\n\tBEGIN MESSAGE_MAP(类名，CView)    //消息映射表的起点\n\t//{{AFX_MSG_MAP(对应类)\n\t//具体的消息映射宏\n\t//AFX_MSG_MAP\n\t...\n\tEND_MESSAGE_MAP()\t\t\t\t\t//消息映射表的终点\n\t\n```\n<br>\n## 消息响应函数\n根据前面的函数声明，在函数类的源文件中实现消息响应函数。由此可知，在MFC消息传递的过程当中，程序中出现和消息传递相关的就只有三处：消息响应函数的声明，消息映射表以及消息响应函数的具体定义。\n<br>\n\n## 消息机制实现过程\n在每一个能够接受和发送消息的类中，都会创建一个消息，一个消息映射表，一个消息响应函数的声明和具体的定义。当有消息处理的时候，我们就要在消息映射表中查找看类能不能处理这个消息，消息映射表中，消息的类型和处理消息的函数地址都是一一对应的，如果能够处理这类消息，我们就要查找看是否有处理这个消息的具体方法函数。如果有的话就会执行。\n<br>\n实际上在实现的过程中，在执行我们自己创建的三部分之前，还要有一系列的步骤。MFC中任何一个消息都是和窗口相关联的，每一个窗口的句柄都会和当前类对象的一个指针进行关联，当出现一个消息的时候，我们就能够通过消息携带的一些参数找出这个消息和哪一个窗口句柄相关，然后找到他相对应的类对象指针，把这个类对象的指针，传递给这个窗口类的基类，基类中会调用一个windowproc的函数，这个函数内部会执行一个叫做OnWndMsg的函数，这个函数是真正的消息映射函数。因为传递给windowproc函数的是窗口类对象的指针，所以在OnWndMsg函数内，我们可以查找，窗口类头文件中是否有所需要的响应函数声明，然后再去查看消息映射表，看是否有相应的函数映射宏。如果上述步骤都成功执行，那么，就会顺利的调用消息响应函数来处理这个消息。\n\n","slug":"MFC的消息映射机制","updated":1419898404000,"excerpt":"","_id":"sairt3q2rslnr26m","comments":true,"layout":"post","photos":[],"link":""},{"title":"TCP运输连接的管理","categories":["ofps7i7zi0zt6wuj"],"date":1419128869000,"tags":["8u5k1qrjxmxqoj4q","pfh4hkh1eqdtx3gu","uuyyus036pzw6j46","7bhe1xim8o34gpgy"],"content":"<blockquote>\n<p>tcp是面向连接的一种运输层的协议，它提供可靠的数据传输服务。任何一次利用TCP连接传输数据的过程都离不开，连接的创建，数据的传送，连接的释放。</p>\n</blockquote>\n<p><br><br><br></p>\n<h2 id=\"TCP连接的建立\">TCP连接的建立</h2>\n<p><br><br>tcp连接的建立，也就是我们常说的三次握手的过程。tcp连接是基于客户端和服务器模式的，再每一次的通信中，客户端作为主动，服务端作为被动。<br>进程的管理有PCB进程控制块，tcp连接的管理同样有TCB传输控制块，里面存放和很多再传输过程中需要的连接信息。</p>\n<ol>\n<li>对于服务器来说，再连接没有建立之前，我们要做的，就是做好准备，等待客户端的请求发过来。所以说，再连接建立的准备阶段，服务器的进程需要创建TCB传输控制块，并且将服务器进程设置为监听状态，以便能够随时收取到客户端传来的信息。<br><br></li>\n<li>客户端也同样需要创建TCB来做好传输信息的准备。之后便可以由客户端为起始点，发送TCP报文段与服务器端进行通讯。此时发送的报文段有几个比较特殊的情况，首先，此时的TCP报文段SYN=1,ACK=0.首部的信息如果被设置成这样就证明这是一个连接请求报文段。此报文段是不携带任何数据的，但是这个报文段却要占用一个序号。此时seq有一个初始值 x。此时，客户端进入三次握手中的第一个状态：同步已发送<br><br></li>\n<li>客户端请求的报文发送给服务器端之后。服务端接受到这个报文，即向客户端发送确认报文。此时报文段的首部，又有了一些变化，比如，SYN=1,ACK=1。此时表明，服务器发送的这个报文，就是同意连接的响应报文。并且确认号ack = x + 1，同时，这一次的报文段也不许携带任何的数据，但是却要占用一个序号，则seq有一个初值y。此时，服务器端进入三次握手当中的第二个状态：同步已接收。<br><br></li>\n<li>接下来便是TCP连接建立中，最重要的第三次握手，也是能够保证TCP连接可靠正确建立的一步。客户端再收到了服务器端发来的确认响应的报文之后，还要再向像服务器端发送一个确认报文来保证连接的正确建立。把ACK=1，此时的报文和前面两次握手的报文不同，这一次的报文可以携带一些数据，如果携带数据了，那么下一次发送报文的序号就是x+2,如果此次没有携带数据，那么就不会占用序号下一次发送的数据序号仍然是x+1.此时，客户端进入三次握手中的第三个状态，连接已建立。服务器端再收到这个确认报文的时候，也同样会进入这个状态，此时TCP的连接建立完成，可以正常发送数据。</li>\n</ol>\n<p><br><br><br></p>\n<h2 id=\"为什么要发送第三次确认报文\">为什么要发送第三次确认报文</h2>\n<p><br></p>\n<p>设计协议的科学家们，还是考虑到了我们网络的实际情况。网络中如果A（客户端）再向B（服务端）建立TCP连接的过程中，如果因为网络环境差的话，A的第一次请求报文丢失了，超时重传机制会重新传递客户端的连接建立的请求报文，让连接正常建立，此时是没有人和问题的。但是，如果再传输的过程中，第一次的请求报文没有丢失，而是再传输的过程中滞留了，超时重传机制虽然可以像前面那样保证连接的正确建立，但是，如果在此连接释放的时候，之前滞留的那个请求报文又传递到了服务端，如果没有第三次确认的话，两次握手就建立连接，此时客户端觉得没有这个连接不发送任何信息，服务器端在第二次握手之后却一直在等待着客户端传来信息这时候就造成了死锁的情况，连接一直在建立明确什么事也不做。</p>\n","source":"_posts/Tcp运输连接的管理.md","raw":"title: TCP运输连接的管理\ncategories: 计算机网络\ndate: 2014-12-21 10:27:49\ntags: [os, 计算机网络, 读书笔记, 基础知识]\n---\n\n\n\n> tcp是面向连接的一种运输层的协议，它提供可靠的数据传输服务。任何一次利用TCP连接传输数据的过程都离不开，连接的创建，数据的传送，连接的释放。\n\n<br>\n<br>\n## TCP连接的建立\n\n<br>\ntcp连接的建立，也就是我们常说的三次握手的过程。tcp连接是基于客户端和服务器模式的，再每一次的通信中，客户端作为主动，服务端作为被动。\n进程的管理有PCB进程控制块，tcp连接的管理同样有TCB传输控制块，里面存放和很多再传输过程中需要的连接信息。\n\n1. 对于服务器来说，再连接没有建立之前，我们要做的，就是做好准备，等待客户端的请求发过来。所以说，再连接建立的准备阶段，服务器的进程需要创建TCB传输控制块，并且将服务器进程设置为监听状态，以便能够随时收取到客户端传来的信息。\n<br>\n2. 客户端也同样需要创建TCB来做好传输信息的准备。之后便可以由客户端为起始点，发送TCP报文段与服务器端进行通讯。此时发送的报文段有几个比较特殊的情况，首先，此时的TCP报文段SYN=1,ACK=0.首部的信息如果被设置成这样就证明这是一个连接请求报文段。此报文段是不携带任何数据的，但是这个报文段却要占用一个序号。此时seq有一个初始值 x。此时，客户端进入三次握手中的第一个状态：同步已发送\n<br>\n3. 客户端请求的报文发送给服务器端之后。服务端接受到这个报文，即向客户端发送确认报文。此时报文段的首部，又有了一些变化，比如，SYN=1,ACK=1。此时表明，服务器发送的这个报文，就是同意连接的响应报文。并且确认号ack = x + 1，同时，这一次的报文段也不许携带任何的数据，但是却要占用一个序号，则seq有一个初值y。此时，服务器端进入三次握手当中的第二个状态：同步已接收。\n<br>\n4. 接下来便是TCP连接建立中，最重要的第三次握手，也是能够保证TCP连接可靠正确建立的一步。客户端再收到了服务器端发来的确认响应的报文之后，还要再向像服务器端发送一个确认报文来保证连接的正确建立。把ACK=1，此时的报文和前面两次握手的报文不同，这一次的报文可以携带一些数据，如果携带数据了，那么下一次发送报文的序号就是x+2,如果此次没有携带数据，那么就不会占用序号下一次发送的数据序号仍然是x+1.此时，客户端进入三次握手中的第三个状态，连接已建立。服务器端再收到这个确认报文的时候，也同样会进入这个状态，此时TCP的连接建立完成，可以正常发送数据。\n\n<br>\n<br>\n\n## 为什么要发送第三次确认报文\n<br>\n\n设计协议的科学家们，还是考虑到了我们网络的实际情况。网络中如果A（客户端）再向B（服务端）建立TCP连接的过程中，如果因为网络环境差的话，A的第一次请求报文丢失了，超时重传机制会重新传递客户端的连接建立的请求报文，让连接正常建立，此时是没有人和问题的。但是，如果再传输的过程中，第一次的请求报文没有丢失，而是再传输的过程中滞留了，超时重传机制虽然可以像前面那样保证连接的正确建立，但是，如果在此连接释放的时候，之前滞留的那个请求报文又传递到了服务端，如果没有第三次确认的话，两次握手就建立连接，此时客户端觉得没有这个连接不发送任何信息，服务器端在第二次握手之后却一直在等待着客户端传来信息这时候就造成了死锁的情况，连接一直在建立明确什么事也不做。\n","slug":"Tcp运输连接的管理","updated":1419898404000,"excerpt":"","_id":"yzt8daaychd8puyu","comments":true,"layout":"post","photos":[],"link":""},{"title":"自己实现和malloc有关的函数","date":1416330928000,"categories":["1738y9s4gafvcrll"],"tags":["8u5k1qrjxmxqoj4q"],"description":null,"content":"<blockquote>\n<p>早晨起来看了一篇博文，关于实现malloc，感觉比较有兴趣，遂读之，实现之，不在做个看客，实践最重要。把其中我遇到的问题和我觉得需要注意的点摆上来，供大家参考。<br>声明：本文的主题思想还是原博主的，我插的图部分也是原博主的，写在我的博客里就是想添加些自己的理解供自己复习，没任何想侵占他人果实的想法。</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"malloc的自我介绍\">malloc的自我介绍</h2>\n<p><br><br>大家都清楚，malloc是做动态内存分配用的，与他相关的还有free和realloc。<br>malloc的正式定义如下所示：</p>\n<pre><code><span class=\"keyword\">void</span>* malloc(size_t <span class=\"keyword\">size</span>);\n</code></pre><p>这就是malloc函数的原型.malloc函数主要是在堆中进行分配内存的，每次在调用malloc函数的时候至少会分配size字节大小的内存空间。也可以看到的是，malloc函数返回一个指针。这个指针值指向的应该是所分配内存区域中的起始部分。在我们不断用malloc分配内存的时候，不会出现分配重叠的现象，也就是说，同一块内存区域不会被分配两次，除非有一次分配完之后又用free释放掉。</p>\n<p><br></p>\n<h2 id=\"Linux内存管理\">Linux内存管理</h2>\n<p><br></p>\n<ol>\n<li>物理地址与逻辑地址的关系<br>既然是关于内存管理，又是在Linux平台下实现，那么利用用到Linux内存管理的知识。<br>Linux内存管理中，普遍用了一种计算机当中很重要的抽象叫做虚拟存储器。<a href=\"http://fengzixu.net/2014/11/12/%E9%87%8D%E8%AF%BBCSAPP%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/\" target=\"_blank\" rel=\"external\">CSAPP</a>这篇文章中我做了一些解释，大体上就是让每一个进程在运行的时候都看作自独享了2^N次方字节的内存，N是计算机子长，这样的话，方面我们的编程和管理。在学操作系统的时候，虽然学过了逻辑地址到物理地址的转化，但是还是没明白为什么，今天才知道，因为在汇编的那一层中，由于程序运行时所看到的都是虚拟的内存地址，要真正的实现对内存的操作，就要把我们一开始的虚拟的逻辑地址转换成真正的物理内存地址，这样才能够达到目的。</li>\n<li>内存的管理形式<br>学过OS的都明白，内存管理当中有段式管理，页式管理以及段页式管理。也就是说，在内存管理当中， 内存的管理单位不是一个字节，也不是一位，而是一页。每一页都有固定的大小，具体的详情，想了解的可以戳这里<a href=\"http://blog.csdn.net/xr_acmer/article/details/24792143\" target=\"_blank\" rel=\"external\">操作系统中的内存存储管理</a>。在操作系统中，管理内存存储或者说是管理逻辑地址到物理地址映射的结构中有一个比较重要，就是页表。页表中有页号，根据偏移量可以找到表中对应的项，然后就可以通过这些数据定位本页的信息被存储到的真实的物理内存地址。所以，如果是利用页式存储来管理内存的话，那么逻辑地址应该有两部分，一部分是页号，另一部分是偏移量。<br><img src=\"http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png\" alt=\"\"><br>上图分别是机器子长为64位和32位的内存的逻辑地址形式。</li>\n</ol>\n<p><img src=\"http://img.my.csdn.net/uploads/201411/14/1415928966_2219.png\" alt=\"\"><br>上图显示了如何容逻辑地址到真实物理地址的转化，学操作系统的时候划过很多次，原博主的感觉简略了一点，所以自己花了一个。</p>\n<p>3.内存的调度<br>（看了原博主的文章，有点相见恨晚的感觉，因为这位大牛也是读过CSAPP的人，ALI的大神）<br>我们的程序在需要数据的时候，总会根据指令中的虚拟内存地址通过页表映射到真实的物理内存上，然后找到我们需要的数据。但是，页表也是有大小的，如果一旦我们需要的那一页，页表中没有，那么就会发生缺页中断现象。此时就会从磁盘中把相应的那一块调入到内存中来。这期间涉及到了缺页中断算法，替换算法等等。</p>\n<ol>\n<li>聪明的科学家们<br>计算机就是为了能让重复性的工作得到更高的效率。为了加快信息的传输，我们在内存和CPU之间设立了高速缓存，现在在地址映射查找页表的时候，我们同样会遇到两次访问相同的页表项的问题。内存访问毕竟还是很慢，所以科学家们也通过OS的局部性原理，借鉴高速缓存的处理办法，在地址映射的过程中加入了TLB（我们学的时候管他叫做快表）。<br>（1）如果在页表中查找的时候找到需要的一项，在进行下一步的时候也需要把这一项写入到TLB中。<br>（2）如果页表中没有找到需要的，在硬盘中找到之后，不但要将这一项写回页表，还要把这一项加入到TLB中。<br>所以，在地址映射的时候，首先访问的应该是TLB，没有的再去找页表，找到的话执行（1）操作，找不到的话，说明缺页了，则执行第二步。</li>\n</ol>\n<p>图示如下，大家可以参考我上面那篇关于内存管理的文章看一看，很容易理解。<br><img src=\"http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png\" alt=\"\"></p>\n<p> <br></p>\n<h2 id=\"Linux进程级内存管理\">Linux进程级内存管理</h2>\n<p><br><br>以64bit的系统为例来说，地址空间应该是2^64字节。但是实际用到的只有其中的47bit是可用的，其余的17位作为扩展。内存的模型是高地址端为起始端，随着内存的使用，开辟空间的时候，地址不是向上增长，而是向下减少。高地址部分，也就是起点，是操作系统专用的0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，中间隔开一段用作以后扩展的空间，最后是属于用户的部分0x0000000000000000 ~ 0x00007FFFFFFFFFFF。</p>\n<p>我们平时所运行的程序，都是在用户空间进行创建和删除内存空间的，操作系统的部分是不能够让我们直接去访问的。对于整个的一段用户空间来说，分为了几个部分，每个部分存储的东西或者用作都是有特殊的规定。</p>\n<p><img src=\"http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png\" alt=\"\"><br>在用户空间中分为这样几个区域：</p>\n<ul>\n<li>code:假设我们写了一个程序。最后编译链接所生成的机器码就是存在这里面</li>\n<li>date:存储了初始化的全局变量(个人理解是属于静态存储区，因为全局变量也就是静态变量)</li>\n<li>BSS：未初始化的全局变量</li>\n<li>Heap：这一部分叫做堆。像malloc，new这些动态分配内存的函数一般来说都是从堆中开辟内存空间的。并且要注意的是，堆和栈有一个不同点就是，堆在开辟新的空间的时候是从低地址向高地址扩充的。</li>\n<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长（这里不太清楚，是摘抄自原博文的）</li>\n<li>Stack：这也就是栈，一般来说，在函数调用，或者自动变量的存储上，都会用到这里，栈的扩张是从高地址向低地址扩充。</li>\n</ul>\n<p><br></p>\n<h2 id=\"对堆的管理\">对堆的管理</h2>\n<p><br><br>malloc函数一般都是在堆内存中开辟所需要的内存空间。<br>进程看到的都是虚拟的地址空间，堆内存的虚拟地址空间部分也理应要映射到物理内存中。由于实际的物理内存空间有限，所以堆内存的的全部空间不能够一次性全都映射到物理内存中，只能映射一部分。所以linux中就设置了一个break指针来进行管理.从堆的起始地址开始，一直到break指针指向的地方位置，都是虚拟的堆内存空间能够映射到实际物理内存的部分。也就是说， 在程序运行的过程中，只能使用这些被映射的部分，因为只有映射到物理内存上了，你才能够真正的使用，光给进程虚拟的内存地址是没用的。<br><br><br><br></p>\n<h2 id=\"brk与sbrk\">brk与sbrk</h2>\n<p><br></p>\n<pre><code> <span class=\"type\">int</span> brk(<span class=\"type\">void</span> *<span class=\"keyword\">addr</span>)；\n <span class=\"type\">void</span> *sbrk(intptr_t increment);\n</code></pre><p>两个函数都有着自己的作用。brk的作用是设置break指针的值。而sbrk是把break的值从现在的状态移动increment个增量。brk成功运行返回0，否则返回-1.sbrk成功的时候返回break再没增加之前的值，而失败的时候会返回(void *)-1。<br>在设置break值的时候，由于内存是按页来进行内存映射的，逻辑上的每一页映射到物理内存中的每一块，或者是每一帧。如果设置的break没有指向到某一个页的边界，他会自动的向后指向一个完整的页，也就是说实际设置的break的值可能会大一些。<br><br><br><br></p>\n<h2 id=\"Linux给进程的资源限制\">Linux给进程的资源限制</h2>\n<p>每一个进程所享用的资源不是无限制的，包括这个进程所占用的内存空间。linux中有相应的API可以获取到一个进程所能够享用的资源的上限值。<br>每一个进程都有一个rlimit的结构体，用于存储这个进程的资源上限值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> rlimit {</div><div class=\"line\">rlim_t rlim_cur;  <span class=\"comment\">/* Soft limit */</span></div><div class=\"line\">rlim_t rlim_max;  <span class=\"comment\">/* Hard limit (ceiling for rlim_cur) */</span>};</div></pre></td></tr></table></figure>\n\n<p>其中rlim_cur是软限制，而rlim_max是硬限制。也就是说，我们可以通过更改软限制的值也更改一个进程所能够拥有的资源，但是不能够超过硬限制的值，硬限制的值我们是不能够改动的。<br><br></p>\n<h2 id=\"malloc函数的实现\">malloc函数的实现</h2>\n<p><br><br>将堆内存的空间以块的形式组织起来，每一块的空间都由数据区和记录区组成。数据区是真正可用的内存空间，malloc返回的地址也是数据区的首地址，记录区主要是用来记录这一块空间内的数据区大小，指针，空闲位等等。可以将堆内存空间中的每一个块抽象成一个链表中的一个节点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> s_block *t_block;</div><div class=\"line\"><span class=\"keyword\">struct</span> s_block {</div><div class=\"line\">    size_t size;  <span class=\"comment\">/* 数据区大小 */</span></div><div class=\"line\">    t_block next; <span class=\"comment\">/* 指向下个块的指针 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">free</span>;     <span class=\"comment\">/* 是否是空闲块 */</span></div><div class=\"line\">    <span class=\"keyword\">int</span> padding;  <span class=\"comment\">/* 填充4字节，保证meta块长度为8的倍数 */</span></div><div class=\"line\">    <span class=\"keyword\">char</span> data[<span class=\"number\">1</span>]  <span class=\"comment\">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></div><div class=\"line\">};</div></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"寻找合适的block\">寻找合适的block</h3>\n<p><br><br>一般来说在进行内存分配的时候，有两种分配方法，一种是首次适应，一种是最佳适应。在遍历的时候要时刻记下我们当前遍历的这个块，以便如果一旦没有在现有的块中找到，要新开辟一个块的时候，可以利用最后一次遍历的块和新开辟的利用指针连接起来。<br>首次适应：从起始地址开始，一直到能够找到一个大于等于要求大小的内存空间位置，是第一个满足条件的。<br>最佳适应：基本上要遍历所有空闲的block一遍，找到最接近我们要求大小的块。</p>\n</li>\n<li><h3 id=\"分配一个新的Block\">分配一个新的Block</h3>\n<p>如果遍历完所有额Block都没有发现大小合适的，那么就需要新开辟一个block块。主要是靠移动Break指针来进行分配的，调用sbrk这个系统函数。</p>\n</li>\n</ul>\n<p>上面两个功能的代码如下：<br><br></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*编写一个查找一个合适块的函数，利用首次适应算法*/</span></div><div class=\"line\">t_block find_a_block(t_block *last,size_t size){</div><div class=\"line\"></div><div class=\"line\">        t_block temp = firstblock;\t<span class=\"comment\">//获取链表的头</span></div><div class=\"line\">        <span class=\"keyword\">while</span>(temp&&!(temp.<span class=\"built_in\">free</span>&&temp.size&gt;=size)){</div><div class=\"line\">                *last = temp;\t<span class=\"comment\">//保存当前遍历的块，进入循环中的都是不合格的块</span></div><div class=\"line\">                temp = temp-&gt;next;</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">return</span> temp;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*如果现有的块都不能满足，则要开辟一个新的块*/</span></div><div class=\"line\"></div><div class=\"line\">t_block add_block(t_block *last,size_t size){</div><div class=\"line\"></div><div class=\"line\">        t_block t = sbrk(<span class=\"number\">0</span>);    <span class=\"comment\">//获取现在的break指针</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(sbrk(BLOCK_SIZE+size) == (<span class=\"keyword\">void</span>*)-<span class=\"number\">1</span>)  <span class=\"comment\">//判断是否移动指针成功</span></div><div class=\"line\">                <span class=\"keyword\">return</span> NULL;</div><div class=\"line\">        t-&gt;size = size;         <span class=\"comment\">//设置好新块的详细信息</span></div><div class=\"line\">        t-&gt;next = NULL;</div><div class=\"line\">        <span class=\"keyword\">if</span>(last)                        <span class=\"comment\">//接上最后新分配的节点</span></div><div class=\"line\">                last-&gt;next = t;</div><div class=\"line\">        t-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;                    <span class=\"comment\">//初始化信息</span></div><div class=\"line\">        <span class=\"keyword\">return</span> t;</div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<ul>\n<li><h3 id=\"解决内碎片问题\">解决内碎片问题</h3>\n<br><br>我们都知道在使用首次适应内存分配方式的时候，可能会出现内碎片增多的问题 ，因为有可能很小的一块占用了一块很大的内存空间。所以，如果内碎片的大小 完全能够分裂出一个完整的block来的话，这样会提高内存利用率。</li>\n</ul>\n<p><img src=\"http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-07.png\" alt=\"\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> split_block(t_block b, size_t size){</div><div class=\"line\"> </div><div class=\"line\">         t_block newone = b-&gt;data+s;     <span class=\"comment\">//跨过前一个块的整个数据区</span></div><div class=\"line\">         newone-&gt;size = b-&gt;size - s - BLOCK_SIZE;        <span class=\"comment\">//新分出来的数据区的大小</span></div><div class=\"line\">         newone-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">1</span>;</div><div class=\"line\">         newone-&gt;next = b-&gt;next;</div><div class=\"line\">         b-&gt;next = newone;       <span class=\"comment\">//把分开的节点接起来</span></div><div class=\"line\">         b-&gt;size = size;</div><div class=\"line\"> }</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<ul>\n<li><h3 id=\"mallco函数的具体实现\">mallco函数的具体实现</h3>\n<br><br>首先要创建一个链表的头部first_block.另外，加入我们已经创建了一些block，在利用malloc开辟内存空间的时候可以查找这些已经存在的块，看有没有合适的。如果有的话，要检查，分配完我所需要的空间之后，是否还留有剩余的空间可以进行block分裂，也就是处理内碎片。（PS:原博主的文章说希望Malloc函数分配的数据区的内存大小尽量为8字节的倍数，说是要对齐，如果不是8的倍数的时候可能还会合理的进行扩大，不知道为什么，等搞懂了再写一篇关于这个的东西出来）当然，在处理内碎片的时候要判断剩余的空间至少要满足BLOCK_SIZE（meta-data的大小，也就是记录信息的那个节点）+8。<br>如果没有合适的块，那么就需要重新开辟一段新的内存空间，这个时候也就需要break指针的操作。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> *<span class=\"built_in\">malloc</span>(size_t size){</div><div class=\"line\"></div><div class=\"line\">        t_block t,b,last;</div><div class=\"line\">        size_t s = align8(size);</div><div class=\"line\">        <span class=\"keyword\">if</span>(first_block) <span class=\"comment\">//如果链表不为空，也就是之前已经在属于堆的内存部分开辟了一些空间</span></div><div class=\"line\">        {</div><div class=\"line\">                last = first_block;     <span class=\"comment\">//保存链表头</span></div><div class=\"line\">                b = find_a_block(&last,s);      <span class=\"comment\">//找看是否有合适的块</span></div><div class=\"line\">                <span class=\"keyword\">if</span>(b)   <span class=\"comment\">//找到</span></div><div class=\"line\">                {</div><div class=\"line\">                        <span class=\"keyword\">if</span>((b-&gt;size-s)&gt;=(BLOCK_SIZE+<span class=\"number\">8</span>))         <span class=\"comment\">//看是否可以处理内碎片 </span></div><div class=\"line\">                                split_block(b,s);</div><div class=\"line\">                        b-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">0</span>;            <span class=\"comment\">//把剩余的部分已经分裂出去，剩下的都已经用完了，所以不再可用</span></div><div class=\"line\"></div><div class=\"line\">                }</div><div class=\"line\"></div><div class=\"line\">                <span class=\"keyword\">else</span>{   <span class=\"comment\">//如果没找到合适的</span></div><div class=\"line\"></div><div class=\"line\">                        b = add_block(last,size);       <span class=\"comment\">//在末尾添加一块        </span></div><div class=\"line\">                        <span class=\"keyword\">if</span>(!b)</div><div class=\"line\">                                <span class=\"keyword\">return</span> NULL;</div><div class=\"line\"></div><div class=\"line\">                   }</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">else</span>{</div><div class=\"line\">        <span class=\"comment\">//如果链表是空的，那么就把这个作为链表的头部</span></div><div class=\"line\"></div><div class=\"line\">                b = add_block(NULL,size);</div><div class=\"line\">                <span class=\"keyword\">if</span>(!b)</div><div class=\"line\">                        <span class=\"keyword\">return</span> NULL;</div><div class=\"line\">                first_block = b;</div><div class=\"line\">        }</div><div class=\"line\">       <span class=\"keyword\">return</span> b-&gt;data;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<h2 id=\"calloc函数的实现\">calloc函数的实现</h2>\n<p><br><br>实现完malloc函数，对于calloc函数来说需要做的就只是将数据区的值置为0.<br>看原来博主的博文时，发现了一个我不理解的地方就是size_t这个数据类型，因为作者把一个指针的值保存在了这个数据类型的变量里面，觉得有点不懂，查了一下文档。size_t是无符号整数类型的一个别名。他能够表示所有在内存中对象的大小，并且作为sizeof运算符的返回值。为什么要用这个数据类型，主要是为了不同平台之间的移植，因为对于Int longint等等这些数据类型，在不同的机器和平台上的结果可能不一样，所以才会出现这种通用的数据类型。</p>\n<p>并且，由于我们之前在设置数据区大小的时候，都是8字节的倍数，那么在置为0的时候也不用一个字节一个字节的设置，可以每次设置八字节一组把他们置为0.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">void</span> *<span class=\"built_in\">calloc</span>(size_t number, size_t size){</div><div class=\"line\"></div><div class=\"line\">        size_t *ptr;</div><div class=\"line\">        size_t s8,i;</div><div class=\"line\">        ptr = <span class=\"built_in\">malloc</span>(number*size);</div><div class=\"line\">        <span class=\"keyword\">if</span>(ptr){</div><div class=\"line\">        </div><div class=\"line\">        s8 = align8(number*size)&gt;&gt;<span class=\"number\">3</span>;   <span class=\"comment\">//算出有多少个八个字节</span></div><div class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; s8; i ++)        <span class=\"comment\">//以八个字节为单位进行初始化</span></div><div class=\"line\">        </div><div class=\"line\">                ptr[i] = <span class=\"number\">0</span>;</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">return</span> ptr;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<h2 id=\"free函数的实现\">free函数的实现</h2>\n<p><br><br>free函数的实现并没有想象当中那么容易。</p>\n<ol>\n<li>要首先确定传进来的地址是不是有效地址，即是不是在first和break范围之内的值，并且还要确定要释放的这一段的内存空间是不是malloc函数创建的。</li>\n<li>如何解决释放空间后的碎片问题</li>\n</ol>\n<p>想对于第一个问题中的确定要释放的这一块是不是malloc函数创建的，可以在原来的meta结构体中添加一个指针值，这个指针值存储在用malloc创建块的时候数据区的地址。这样的话，在free函数接受传进来的地址值时首先和这个指针值进行比，如果不相等的话，那么就证明不是malloc分配的内存空间可以拒绝释放。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">t_block get_block_add(<span class=\"keyword\">void</span> *p){                 <span class=\"comment\">//获得这一块中meta的地址，找到magic_ptr返回</span></div><div class=\"line\"></div><div class=\"line\">        t_block temp = p;</div><div class=\"line\">        <span class=\"keyword\">return</span> p = (temp -= BLOCK_SIZE);</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> judge_ptr(<span class=\"keyword\">void</span> *p){         <span class=\"comment\">//传递进来的是数据区的地址，因为用户也只能够得到数据区的地址</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span>(first_block){</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">if</span>(p&gt;first_block&&p&lt;sbrk(<span class=\"number\">0</span>))    <span class=\"comment\">//如果传递进来的地址在堆的可映射合法空间</span></div><div class=\"line\">                <span class=\"keyword\">return</span> p==get_block_add(p)-&gt;magic_ptr;  <span class=\"comment\">//查看穿进来的地址和malloc申请空间时设置的数据区地址是否相等</span></div><div class=\"line\">        }       </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br><br>在判断完传进来的指针是有效的指针之后，释放完内存空间在内存中就会留有相应的内存碎片。所以free函数采用，如果释放完某一段的内存空间的时候，如果周围还有空闲的内存区域就把他们都合并起来。这类似于内存管理中的连续分配方式中的伙伴系统，只不过伙伴系统在分配和回收的时候都有相应比较特殊的规定。所以，为了一个节点的两端都能够进行连接，可以把原来的结构体改成双向链表。<br><br></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">free</span>(<span class=\"keyword\">void</span> *p){</div><div class=\"line\"></div><div class=\"line\">        t_block ptr;</div><div class=\"line\">        <span class=\"keyword\">if</span>(judge_ptr(p))        <span class=\"comment\">//判断指针是否有效</span></div><div class=\"line\">        {</div><div class=\"line\"></div><div class=\"line\">                ptr = get_block_add(p);         <span class=\"comment\">//获取meta数据块的指针</span></div><div class=\"line\">                ptr-&gt;<span class=\"built_in\">free</span> = <span class=\"number\">1</span>;                  <span class=\"comment\">//这个区域被释放，空闲设为正</span></div><div class=\"line\">                <span class=\"keyword\">if</span>(ptr-&gt;pre && ptr-&gt;pre-&gt;<span class=\"built_in\">free</span>)  <span class=\"comment\">//前面不为空，并且是空闲的，进行合并，之所以要判断是否为空闲，因为合并函数一直都是向后合并</span></div><div class=\"line\">                        ptr = merge_block(ptr-&gt;pre);</div><div class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ptr-&gt;next)              <span class=\"comment\">//如果后面的不为空，合并函数内部可以判断是否后面的块为空闲，但是不再改动指针，因为合并之后的空闲区域地址就是我们要释放</span></div><div class=\"line\">   的这一块的地址。</div><div class=\"line\">                        merge_block(ptr);</div><div class=\"line\">                <span class=\"keyword\">else</span>    </div><div class=\"line\">                {</div><div class=\"line\">                        <span class=\"keyword\">if</span>(ptr-&gt;pre)            <span class=\"comment\">//如果两边都不是空，还是有两中可能，一种是两边什么都没有，这一块本来就是堆空间中的最后一块，另一种是前面的已经被占用了</span></div><div class=\"line\">                                ptr-&gt;pre-&gt;next = NULL;</div><div class=\"line\">                        <span class=\"keyword\">else</span>    </div><div class=\"line\">                                first_block = NULL;</div><div class=\"line\">                        brk(ptr);       <span class=\"comment\">//重新设置break指针的值，因为无论堆内存空间中是否为空，释放掉之后都要重新设置</span></div><div class=\"line\">                }</div><div class=\"line\">        }</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br><br>具体的free函数的实现如上代码所示，基本的都思路是这样的：</p>\n<ol>\n<li>首先要判断传递进来的指针是不是有效的</li>\n<li>设置这一块的free值为1，表示已经释放掉了</li>\n<li>查看前面有没有可以合并的</li>\n<li>查看后面有没有合并的</li>\n<li>都没有的话，很可能前面和后面都已经被占用，或者我们此时释放的这块就是堆内存空间中的最后一块。</li>\n<li>如果真的是最后一块，那么就把链表的头部设置为NULL,并重新设置break指针。<br><br></li>\n</ol>\n<h2 id=\"realloc函数的实现\">realloc函数的实现</h2>\n<p><br><br>感觉还是首先要了解一下realloc函数的作用吧。妹的，coding的时候才发现，长期不写代码我连快排都忘了，realloc这种函数都忘了功能了。<br>realloc这个函数的功能主要是重新分配内存块。函数接受两个参数，一个是原来分配的内存地址，另外一个是重新要分配的内存大小。如果已经分配的空间大于等于size，就应该返回原来的分配地址而不用重新分配。如果重新要分配的大小比原来已经分配的空间还要小，那么可以把剩余的空闲空间进行合并。如果新要求分配的内存空间原有的大小满足不了需求的话，那么如果原来的内存空间后面有空闲区域，可以选择合并，如果没有，那么就只能重新再找地方分配。分配完所需要的空间之后，要把原来的数据都要复制到新的区域内。</p>\n<ol>\n<li>首先要实现的就是复制数据的函数</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> copy_data(t_block start, t_block end){</div><div class=\"line\"></div><div class=\"line\">        size_t *sdata, *edata;</div><div class=\"line\">        size_t i;</div><div class=\"line\">        sdata = (size_t *)start-&gt;magic_ptr;</div><div class=\"line\">        edata = (size_t *)end-&gt;magic_ptr;</div><div class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; (i * <span class=\"number\">8</span>) &lt; start-&gt;size && (i * <span class=\"number\">8</span>) &lt; end-&gt;size; i++)</div><div class=\"line\">                edata[i] = sdata[i];</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<ol>\n<li>然后就是实现realloc函数了</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">void</span> *realloc(<span class=\"keyword\">void</span> *p, size_t size){</div><div class=\"line\"></div><div class=\"line\">        size_t s;</div><div class=\"line\">        t_block newone,b;</div><div class=\"line\">        <span class=\"keyword\">void</span> *new_ptr;</div><div class=\"line\">        <span class=\"keyword\">if</span>(!p)          <span class=\"comment\">//如果指针为空则默认执行malloc函数</span></div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"built_in\">malloc</span>(size);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>(judge_ptr(p))        <span class=\"comment\">//查看p是不是malloc返回的指针</span></div><div class=\"line\">        {</div><div class=\"line\">                s = align8(size);</div><div class=\"line\">                b = get_block_add(p);</div><div class=\"line\">                <span class=\"keyword\">if</span>(b-&gt;size&gt;=s)                  <span class=\"comment\">//如果原来分配的大小大于要求的，那么就不再重新分配</span></div><div class=\"line\">                {</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span>(b-&gt;size-s&gt;=(BLOCK_SIZE+<span class=\"number\">8</span>))   <span class=\"comment\">//在满足自身要求的同时还有可以分裂的空间</span></div><div class=\"line\">                        {</div><div class=\"line\">                                split_block(b,s);</div><div class=\"line\">                        }</div><div class=\"line\">                }</div><div class=\"line\">                <span class=\"keyword\">else</span>                                    <span class=\"comment\">//如果本身的空间不够，看是否可以向后进行扩展</span></div><div class=\"line\">                {</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">if</span>(b-&gt;next&&b-&gt;<span class=\"built_in\">free</span>)</div><div class=\"line\">                        {</div><div class=\"line\">                                <span class=\"keyword\">if</span>((b-&gt;size+BLOCK_SIZE+b-&gt;next-&gt;size)&gt;=s)       <span class=\"comment\">//如果加上后面的空间满足要求大小</span></div><div class=\"line\">                                {</div><div class=\"line\">                                        merge_block(b);</div><div class=\"line\">                                         <span class=\"keyword\">if</span>(b-&gt;size-s&gt;=(BLOCK_SIZE+<span class=\"number\">8</span>))   <span class=\"comment\">//在满足自身要求的同时还有可以分裂的空间</span></div><div class=\"line\">                                        {</div><div class=\"line\">                                                split_block(b,s);</div><div class=\"line\">                                        }</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">                                }</div><div class=\"line\">                        }</div><div class=\"line\"></div><div class=\"line\">                        <span class=\"keyword\">else</span>                            <span class=\"comment\">//向后的空间不能扩展且现有的空间又满足不了需求就只能重新malloc一段内存然后复制数据</span></div><div class=\"line\">                        {</div><div class=\"line\"></div><div class=\"line\">                                        new_ptr = <span class=\"built_in\">malloc</span>(size);</div><div class=\"line\">                                        <span class=\"keyword\">if</span>(!new_ptr)</div><div class=\"line\">                                                <span class=\"keyword\">return</span> NULL;</div><div class=\"line\">                                        t_block temp_ptr = get_block_add(new_ptr);</div><div class=\"line\">                                        copy_data(b,temp_ptr);</div><div class=\"line\">                                        <span class=\"built_in\">free</span>(p);                                <span class=\"comment\">//数据复制过去之后，旧的空间里面的东西也没用了。要删除掉，防止内存泄露</span></div><div class=\"line\">                                        <span class=\"keyword\">return</span> new_ptr;</div><div class=\"line\">                        }</div><div class=\"line\">                }</div><div class=\"line\">                <span class=\"keyword\">return</span> p;</div><div class=\"line\">        }</div><div class=\"line\">        <span class=\"keyword\">return</span> NULL;</div><div class=\"line\"></div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br><br><br></p>\n<h2 id=\"最后的测试和总结\">最后的测试和总结</h2>\n<p><br></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> main()</div><div class=\"line\">{</div><div class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> *p = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>)*<span class=\"number\">5</span>);</div><div class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt;= <span class=\"number\">6</span>; i++)</div><div class=\"line\">                <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&p[i]);</div><div class=\"line\">        <span class=\"keyword\">for</span>(i = <span class=\"number\">2</span>; i &lt;= <span class=\"number\">6</span>; i++)</div><div class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"p[%d] = %d\\n\"</span>, i,p[i]);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br><br>到此为止，和malloc有关的函数就都实现了。自己在机器上测了一个malloc的功能，其他的比如free这些感觉看不出来效果，所以就没试，只试了一个malloc。但是发现了一个奇怪的问题，就是，开辟空间正常，但是输入和输出必须在2这个下标以后输入和输出才能够正常的看到我们所输入的结果。我怀疑是size_t s = align8(size);这个代码，8字节对齐的事情，感觉正好差了0和1这两个下标的元素的大小。字节对齐这东西一直没搞清，CSAPP里面有，到时候好好学学。希望看这篇文章的人能帮我验证验证吧，了解了原理之后，有时间再验证这些细节了，主要是不知道出现什么结果算是正确，比如free，释放之后感觉要gdb调试看看内存才行。<br><br></p>\n<h2 id=\"源代码：戳我\">源代码：<a href=\"https://github.com/fengzixu/malloc-fuction\" target=\"_blank\" rel=\"external\">戳我</a></h2>\n<p><br><br><br></p>\n<h2 id=\"Important_tips：\">Important tips：</h2>\n<ol>\n<li>每一次在开辟新的内存的时候，都是利用修改Break指针来进行的，这也就说明，一开始，堆中是没有任何实际的内存空间映射在物理内存中的。直到我们确实有需求要在堆中开辟空间，malloc函数才通过更改break指针来把虚拟的地址段映射到物理内存中。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</li>\n<li>往往在释放内存的时候，都不是真正的进行释放内存，而只是更改了meta数据块（保存了malloc实际开辟数据区的一些元信息）中的free这一字段的值。从某种意义上来讲,内存是很脏的，他每次在写数据的时候都不是“擦干净在写”而是覆盖的直接写上去。</li>\n<li>个人感觉，对内存的管理，貌似一直就是对象meta数据块这样信息的管理，类似于进程控制块，整个堆内存空间哪里能用，哪里空闲，都是通过每一块的meta数据块中的信息进行存取的，每一块中的所有信息都能够在meta数据块中的各个字段体现出来。感觉蛮方便的。</li>\n</ol>\n","source":"_posts/自己实现和malloc有关的函数.md","raw":"title: 自己实现和malloc有关的函数\ndate: 2014-11-19 01:15:28\ncategories: [OS]\ntags: [os]\ndescription:\n---\n\n> 早晨起来看了一篇博文，关于实现malloc，感觉比较有兴趣，遂读之，实现之，不在做个看客，实践最重要。把其中我遇到的问题和我觉得需要注意的点摆上来，供大家参考。\n声明：本文的主题思想还是原博主的，我插的图部分也是原博主的，写在我的博客里就是想添加些自己的理解供自己复习，没任何想侵占他人果实的想法。\n\n\n<br>\n\n## malloc的自我介绍\n<br>\n大家都清楚，malloc是做动态内存分配用的，与他相关的还有free和realloc。\nmalloc的正式定义如下所示：\n\n    void* malloc(size_t size);\n这就是malloc函数的原型.malloc函数主要是在堆中进行分配内存的，每次在调用malloc函数的时候至少会分配size字节大小的内存空间。也可以看到的是，malloc函数返回一个指针。这个指针值指向的应该是所分配内存区域中的起始部分。在我们不断用malloc分配内存的时候，不会出现分配重叠的现象，也就是说，同一块内存区域不会被分配两次，除非有一次分配完之后又用free释放掉。\n\n<br>\n## Linux内存管理\n<br>\n1. 物理地址与逻辑地址的关系\n既然是关于内存管理，又是在Linux平台下实现，那么利用用到Linux内存管理的知识。\nLinux内存管理中，普遍用了一种计算机当中很重要的抽象叫做虚拟存储器。[CSAPP](http://fengzixu.net/2014/11/12/%E9%87%8D%E8%AF%BBCSAPP%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/)这篇文章中我做了一些解释，大体上就是让每一个进程在运行的时候都看作自独享了2^N次方字节的内存，N是计算机子长，这样的话，方面我们的编程和管理。在学操作系统的时候，虽然学过了逻辑地址到物理地址的转化，但是还是没明白为什么，今天才知道，因为在汇编的那一层中，由于程序运行时所看到的都是虚拟的内存地址，要真正的实现对内存的操作，就要把我们一开始的虚拟的逻辑地址转换成真正的物理内存地址，这样才能够达到目的。\n2. 内存的管理形式\n学过OS的都明白，内存管理当中有段式管理，页式管理以及段页式管理。也就是说，在内存管理当中， 内存的管理单位不是一个字节，也不是一位，而是一页。每一页都有固定的大小，具体的详情，想了解的可以戳这里[操作系统中的内存存储管理](http://blog.csdn.net/xr_acmer/article/details/24792143)。在操作系统中，管理内存存储或者说是管理逻辑地址到物理地址映射的结构中有一个比较重要，就是页表。页表中有页号，根据偏移量可以找到表中对应的项，然后就可以通过这些数据定位本页的信息被存储到的真实的物理内存地址。所以，如果是利用页式存储来管理内存的话，那么逻辑地址应该有两部分，一部分是页号，另一部分是偏移量。\n![](http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png)\n上图分别是机器子长为64位和32位的内存的逻辑地址形式。\n\n![](http://img.my.csdn.net/uploads/201411/14/1415928966_2219.png)\n上图显示了如何容逻辑地址到真实物理地址的转化，学操作系统的时候划过很多次，原博主的感觉简略了一点，所以自己花了一个。\n\n3.内存的调度\n（看了原博主的文章，有点相见恨晚的感觉，因为这位大牛也是读过CSAPP的人，ALI的大神）\n我们的程序在需要数据的时候，总会根据指令中的虚拟内存地址通过页表映射到真实的物理内存上，然后找到我们需要的数据。但是，页表也是有大小的，如果一旦我们需要的那一页，页表中没有，那么就会发生缺页中断现象。此时就会从磁盘中把相应的那一块调入到内存中来。这期间涉及到了缺页中断算法，替换算法等等。\n\n4. 聪明的科学家们\n计算机就是为了能让重复性的工作得到更高的效率。为了加快信息的传输，我们在内存和CPU之间设立了高速缓存，现在在地址映射查找页表的时候，我们同样会遇到两次访问相同的页表项的问题。内存访问毕竟还是很慢，所以科学家们也通过OS的局部性原理，借鉴高速缓存的处理办法，在地址映射的过程中加入了TLB（我们学的时候管他叫做快表）。\n（1）如果在页表中查找的时候找到需要的一项，在进行下一步的时候也需要把这一项写入到TLB中。\n（2）如果页表中没有找到需要的，在硬盘中找到之后，不但要将这一项写回页表，还要把这一项加入到TLB中。\n所以，在地址映射的时候，首先访问的应该是TLB，没有的再去找页表，找到的话执行（1）操作，找不到的话，说明缺页了，则执行第二步。\n\n图示如下，大家可以参考我上面那篇关于内存管理的文章看一看，很容易理解。\n![](http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png)\n\n <br>\n## Linux进程级内存管理\n<br>\n以64bit的系统为例来说，地址空间应该是2^64字节。但是实际用到的只有其中的47bit是可用的，其余的17位作为扩展。内存的模型是高地址端为起始端，随着内存的使用，开辟空间的时候，地址不是向上增长，而是向下减少。高地址部分，也就是起点，是操作系统专用的0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，中间隔开一段用作以后扩展的空间，最后是属于用户的部分0x0000000000000000 ~ 0x00007FFFFFFFFFFF。\n\n我们平时所运行的程序，都是在用户空间进行创建和删除内存空间的，操作系统的部分是不能够让我们直接去访问的。对于整个的一段用户空间来说，分为了几个部分，每个部分存储的东西或者用作都是有特殊的规定。\n\n![](http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png)\n在用户空间中分为这样几个区域：\n- code:假设我们写了一个程序。最后编译链接所生成的机器码就是存在这里面\n- date:存储了初始化的全局变量(个人理解是属于静态存储区，因为全局变量也就是静态变量)\n- BSS：未初始化的全局变量\n- Heap：这一部分叫做堆。像malloc，new这些动态分配内存的函数一般来说都是从堆中开辟内存空间的。并且要注意的是，堆和栈有一个不同点就是，堆在开辟新的空间的时候是从低地址向高地址扩充的。\n- Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长（这里不太清楚，是摘抄自原博文的）\n- Stack：这也就是栈，一般来说，在函数调用，或者自动变量的存储上，都会用到这里，栈的扩张是从高地址向低地址扩充。\n\n<br>\n## 对堆的管理\n<br>\nmalloc函数一般都是在堆内存中开辟所需要的内存空间。\n进程看到的都是虚拟的地址空间，堆内存的虚拟地址空间部分也理应要映射到物理内存中。由于实际的物理内存空间有限，所以堆内存的的全部空间不能够一次性全都映射到物理内存中，只能映射一部分。所以linux中就设置了一个break指针来进行管理.从堆的起始地址开始，一直到break指针指向的地方位置，都是虚拟的堆内存空间能够映射到实际物理内存的部分。也就是说， 在程序运行的过程中，只能使用这些被映射的部分，因为只有映射到物理内存上了，你才能够真正的使用，光给进程虚拟的内存地址是没用的。\n<br>\n<br>\n## brk与sbrk\n<br>\n\n     int brk(void *addr)；\n     void *sbrk(intptr_t increment);\n两个函数都有着自己的作用。brk的作用是设置break指针的值。而sbrk是把break的值从现在的状态移动increment个增量。brk成功运行返回0，否则返回-1.sbrk成功的时候返回break再没增加之前的值，而失败的时候会返回(void *)-1。\n在设置break值的时候，由于内存是按页来进行内存映射的，逻辑上的每一页映射到物理内存中的每一块，或者是每一帧。如果设置的break没有指向到某一个页的边界，他会自动的向后指向一个完整的页，也就是说实际设置的break的值可能会大一些。\n<br>\n<br>\n\n## Linux给进程的资源限制\n每一个进程所享用的资源不是无限制的，包括这个进程所占用的内存空间。linux中有相应的API可以获取到一个进程所能够享用的资源的上限值。\n每一个进程都有一个rlimit的结构体，用于存储这个进程的资源上限值。\n```c\n    struct rlimit {\n    rlim_t rlim_cur;  /* Soft limit */\n    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */};\n```\n其中rlim_cur是软限制，而rlim_max是硬限制。也就是说，我们可以通过更改软限制的值也更改一个进程所能够拥有的资源，但是不能够超过硬限制的值，硬限制的值我们是不能够改动的。\n<br>\n## malloc函数的实现\n<br>\n将堆内存的空间以块的形式组织起来，每一块的空间都由数据区和记录区组成。数据区是真正可用的内存空间，malloc返回的地址也是数据区的首地址，记录区主要是用来记录这一块空间内的数据区大小，指针，空闲位等等。可以将堆内存空间中的每一个块抽象成一个链表中的一个节点。\n```c\ntypedef struct s_block *t_block;\nstruct s_block {\n    size_t size;  /* 数据区大小 */\n    t_block next; /* 指向下个块的指针 */\n    int free;     /* 是否是空闲块 */\n    int padding;  /* 填充4字节，保证meta块长度为8的倍数 */\n    char data[1]  /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */\n};\n```\n\n- ### 寻找合适的block\n<br>\n一般来说在进行内存分配的时候，有两种分配方法，一种是首次适应，一种是最佳适应。在遍历的时候要时刻记下我们当前遍历的这个块，以便如果一旦没有在现有的块中找到，要新开辟一个块的时候，可以利用最后一次遍历的块和新开辟的利用指针连接起来。\n首次适应：从起始地址开始，一直到能够找到一个大于等于要求大小的内存空间位置，是第一个满足条件的。\n最佳适应：基本上要遍历所有空闲的block一遍，找到最接近我们要求大小的块。\n\n- ### 分配一个新的Block\n如果遍历完所有额Block都没有发现大小合适的，那么就需要新开辟一个block块。主要是靠移动Break指针来进行分配的，调用sbrk这个系统函数。\n\n上面两个功能的代码如下：\n<br>\n```c\n /*编写一个查找一个合适块的函数，利用首次适应算法*/\n t_block find_a_block(t_block *last,size_t size){\n \n         t_block temp = firstblock;\t//获取链表的头\n         while(temp&&!(temp.free&&temp.size>=size)){\n                 *last = temp;\t//保存当前遍历的块，进入循环中的都是不合格的块\n                 temp = temp->next;\n         }\n         return temp;\n }\n \n \n /*如果现有的块都不能满足，则要开辟一个新的块*/\n \n t_block add_block(t_block *last,size_t size){\n \n         t_block t = sbrk(0);    //获取现在的break指针\n         if(sbrk(BLOCK_SIZE+size) == (void*)-1)  //判断是否移动指针成功\n                 return NULL;\n         t->size = size;         //设置好新块的详细信息\n         t->next = NULL;\n         if(last)                        //接上最后新分配的节点\n                 last->next = t;\n         t->free = 0;                    //初始化信息\n         return t;\n \n }\n\n```\n<br>\n- ### 解决内碎片问题\n<br>\n我们都知道在使用首次适应内存分配方式的时候，可能会出现内碎片增多的问题 ，因为有可能很小的一块占用了一块很大的内存空间。所以，如果内碎片的大小 完全能够分裂出一个完整的block来的话，这样会提高内存利用率。\n\n![](http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-07.png)\n```c\nvoid split_block(t_block b, size_t size){\n \n         t_block newone = b->data+s;     //跨过前一个块的整个数据区\n         newone->size = b->size - s - BLOCK_SIZE;        //新分出来的数据区的大小\n         newone->free = 1;\n         newone->next = b->next;\n         b->next = newone;       //把分开的节点接起来\n         b->size = size;\n }\n\n```\n<br>\n\n- ### mallco函数的具体实现\n<br>\n首先要创建一个链表的头部first_block.另外，加入我们已经创建了一些block，在利用malloc开辟内存空间的时候可以查找这些已经存在的块，看有没有合适的。如果有的话，要检查，分配完我所需要的空间之后，是否还留有剩余的空间可以进行block分裂，也就是处理内碎片。（PS:原博主的文章说希望Malloc函数分配的数据区的内存大小尽量为8字节的倍数，说是要对齐，如果不是8的倍数的时候可能还会合理的进行扩大，不知道为什么，等搞懂了再写一篇关于这个的东西出来）当然，在处理内碎片的时候要判断剩余的空间至少要满足BLOCK_SIZE（meta-data的大小，也就是记录信息的那个节点）+8。\n如果没有合适的块，那么就需要重新开辟一段新的内存空间，这个时候也就需要break指针的操作。\n\n```c\n  void *malloc(size_t size){\n  \n          t_block t,b,last;\n          size_t s = align8(size);\n          if(first_block) //如果链表不为空，也就是之前已经在属于堆的内存部分开辟了一些空间\n          {\n                  last = first_block;     //保存链表头\n                  b = find_a_block(&last,s);      //找看是否有合适的块\n                  if(b)   //找到\n                  {\n                          if((b->size-s)>=(BLOCK_SIZE+8))         //看是否可以处理内碎片 \n                                  split_block(b,s);\n                          b->free = 0;            //把剩余的部分已经分裂出去，剩下的都已经用完了，所以不再可用\n  \n                  }\n  \n                  else{   //如果没找到合适的\n  \n                          b = add_block(last,size);       //在末尾添加一块        \n                          if(!b)\n                                  return NULL;\n  \n                     }\n          }\n          else{\n          //如果链表是空的，那么就把这个作为链表的头部\n  \n                  b = add_block(NULL,size);\n                  if(!b)\n                          return NULL;\n                  first_block = b;\n          }\n         return b->data;\n  \n  \n  \n  }\n\n```\n<br>\n## calloc函数的实现\n<br>\n实现完malloc函数，对于calloc函数来说需要做的就只是将数据区的值置为0.\n看原来博主的博文时，发现了一个我不理解的地方就是size_t这个数据类型，因为作者把一个指针的值保存在了这个数据类型的变量里面，觉得有点不懂，查了一下文档。size_t是无符号整数类型的一个别名。他能够表示所有在内存中对象的大小，并且作为sizeof运算符的返回值。为什么要用这个数据类型，主要是为了不同平台之间的移植，因为对于Int longint等等这些数据类型，在不同的机器和平台上的结果可能不一样，所以才会出现这种通用的数据类型。\n\n并且，由于我们之前在设置数据区大小的时候，都是8字节的倍数，那么在置为0的时候也不用一个字节一个字节的设置，可以每次设置八字节一组把他们置为0.\n\n```c\n \n void *calloc(size_t number, size_t size){\n \n         size_t *ptr;\n         size_t s8,i;\n         ptr = malloc(number*size);\n         if(ptr){\n         \n         s8 = align8(number*size)>>3;   //算出有多少个八个字节\n         for(i = 0; i < s8; i ++)        //以八个字节为单位进行初始化\n         \n                 ptr[i] = 0;\n         }\n         return ptr;\n }\n \n \n\n```\n\n\n<br>\n## free函数的实现\n<br>\nfree函数的实现并没有想象当中那么容易。\n1. 要首先确定传进来的地址是不是有效地址，即是不是在first和break范围之内的值，并且还要确定要释放的这一段的内存空间是不是malloc函数创建的。\n2. 如何解决释放空间后的碎片问题\n\n想对于第一个问题中的确定要释放的这一块是不是malloc函数创建的，可以在原来的meta结构体中添加一个指针值，这个指针值存储在用malloc创建块的时候数据区的地址。这样的话，在free函数接受传进来的地址值时首先和这个指针值进行比，如果不相等的话，那么就证明不是malloc分配的内存空间可以拒绝释放。\n```c\n t_block get_block_add(void *p){                 //获得这一块中meta的地址，找到magic_ptr返回\n \n         t_block temp = p;\n         return p = (temp -= BLOCK_SIZE);\n }\n \n int judge_ptr(void *p){         //传递进来的是数据区的地址，因为用户也只能够得到数据区的地址\n         \n         if(first_block){\n         \n         if(p>first_block&&p<sbrk(0))    //如果传递进来的地址在堆的可映射合法空间\n                 return p==get_block_add(p)->magic_ptr;  //查看穿进来的地址和malloc申请空间时设置的数据区地址是否相等\n         }       \n         \n         return 0;\n }\n\n```\n<br>\n在判断完传进来的指针是有效的指针之后，释放完内存空间在内存中就会留有相应的内存碎片。所以free函数采用，如果释放完某一段的内存空间的时候，如果周围还有空闲的内存区域就把他们都合并起来。这类似于内存管理中的连续分配方式中的伙伴系统，只不过伙伴系统在分配和回收的时候都有相应比较特殊的规定。所以，为了一个节点的两端都能够进行连接，可以把原来的结构体改成双向链表。\n<br>\n\n```c\n void free(void *p){\n \n         t_block ptr;\n         if(judge_ptr(p))        //判断指针是否有效\n         {\n \n                 ptr = get_block_add(p);         //获取meta数据块的指针\n                 ptr->free = 1;                  //这个区域被释放，空闲设为正\n                 if(ptr->pre && ptr->pre->free)  //前面不为空，并且是空闲的，进行合并，之所以要判断是否为空闲，因为合并函数一直都是向后合并\n                         ptr = merge_block(ptr->pre);\n                 else if(ptr->next)              //如果后面的不为空，合并函数内部可以判断是否后面的块为空闲，但是不再改动指针，因为合并之后的空闲区域地址就是我们要释放\n    的这一块的地址。\n                         merge_block(ptr);\n                 else    \n                 {\n                         if(ptr->pre)            //如果两边都不是空，还是有两中可能，一种是两边什么都没有，这一块本来就是堆空间中的最后一块，另一种是前面的已经被占用了\n                                 ptr->pre->next = NULL;\n                         else    \n                                 first_block = NULL;\n                         brk(ptr);       //重新设置break指针的值，因为无论堆内存空间中是否为空，释放掉之后都要重新设置\n                 }\n         }\n }\n\n```\n<br>\n具体的free函数的实现如上代码所示，基本的都思路是这样的：\n1. 首先要判断传递进来的指针是不是有效的\n2. 设置这一块的free值为1，表示已经释放掉了\n3. 查看前面有没有可以合并的\n4. 查看后面有没有合并的\n5. 都没有的话，很可能前面和后面都已经被占用，或者我们此时释放的这块就是堆内存空间中的最后一块。\n6. 如果真的是最后一块，那么就把链表的头部设置为NULL,并重新设置break指针。\n<br>\n\n\n## realloc函数的实现\n<br>\n感觉还是首先要了解一下realloc函数的作用吧。妹的，coding的时候才发现，长期不写代码我连快排都忘了，realloc这种函数都忘了功能了。\nrealloc这个函数的功能主要是重新分配内存块。函数接受两个参数，一个是原来分配的内存地址，另外一个是重新要分配的内存大小。如果已经分配的空间大于等于size，就应该返回原来的分配地址而不用重新分配。如果重新要分配的大小比原来已经分配的空间还要小，那么可以把剩余的空闲空间进行合并。如果新要求分配的内存空间原有的大小满足不了需求的话，那么如果原来的内存空间后面有空闲区域，可以选择合并，如果没有，那么就只能重新再找地方分配。分配完所需要的空间之后，要把原来的数据都要复制到新的区域内。\n\n1. 首先要实现的就是复制数据的函数\n```c\n void copy_data(t_block start, t_block end){\n \n         size_t *sdata, *edata;\n         size_t i;\n         sdata = (size_t *)start->magic_ptr;\n         edata = (size_t *)end->magic_ptr;\n         for(i = 0; (i * 8) < start->size && (i * 8) < end->size; i++)\n                 edata[i] = sdata[i];\n }\n\n```\n2. 然后就是实现realloc函数了\n \n```c\n void *realloc(void *p, size_t size){\n \n         size_t s;\n         t_block newone,b;\n         void *new_ptr;\n         if(!p)          //如果指针为空则默认执行malloc函数\n                 return malloc(size);\n \n         if(judge_ptr(p))        //查看p是不是malloc返回的指针\n         {\n                 s = align8(size);\n                 b = get_block_add(p);\n                 if(b->size>=s)                  //如果原来分配的大小大于要求的，那么就不再重新分配\n                 {\n \n                         if(b->size-s>=(BLOCK_SIZE+8))   //在满足自身要求的同时还有可以分裂的空间\n                         {\n                                 split_block(b,s);\n                         }\n                 }\n                 else                                    //如果本身的空间不够，看是否可以向后进行扩展\n                 {\n \n                         if(b->next&&b->free)\n                         {\n                                 if((b->size+BLOCK_SIZE+b->next->size)>=s)       //如果加上后面的空间满足要求大小\n                                 {\n                                         merge_block(b);\n                                          if(b->size-s>=(BLOCK_SIZE+8))   //在满足自身要求的同时还有可以分裂的空间\n                                         {\n                                                 split_block(b,s);\n                                         }\n \n \n                                 }\n                         }\n \n                         else                            //向后的空间不能扩展且现有的空间又满足不了需求就只能重新malloc一段内存然后复制数据\n                         {\n \n                                         new_ptr = malloc(size);\n                                         if(!new_ptr)\n                                                 return NULL;\n                                         t_block temp_ptr = get_block_add(new_ptr);\n                                         copy_data(b,temp_ptr);\n                                         free(p);                                //数据复制过去之后，旧的空间里面的东西也没用了。要删除掉，防止内存泄露\n                                         return new_ptr;\n                         }\n                 }\n                 return p;\n         }\n         return NULL;\n \n }\n \n```\n<br>\n<br>\n## 最后的测试和总结\n<br>\n```c\n int main()\n {\n         int i = 0;\n         int *p = (int*)malloc(sizeof(int)*5);\n         for(i = 2; i <= 6; i++)\n                 scanf(\"%d\",&p[i]);\n         for(i = 2; i <= 6; i++)\n                 printf(\"p[%d] = %d\\n\", i,p[i]);\n \n         return 0;\n }\n \n\n```\n<br>\n到此为止，和malloc有关的函数就都实现了。自己在机器上测了一个malloc的功能，其他的比如free这些感觉看不出来效果，所以就没试，只试了一个malloc。但是发现了一个奇怪的问题，就是，开辟空间正常，但是输入和输出必须在2这个下标以后输入和输出才能够正常的看到我们所输入的结果。我怀疑是size_t s = align8(size);这个代码，8字节对齐的事情，感觉正好差了0和1这两个下标的元素的大小。字节对齐这东西一直没搞清，CSAPP里面有，到时候好好学学。希望看这篇文章的人能帮我验证验证吧，了解了原理之后，有时间再验证这些细节了，主要是不知道出现什么结果算是正确，比如free，释放之后感觉要gdb调试看看内存才行。\n<br>\n## 源代码：[戳我](https://github.com/fengzixu/malloc-fuction)\n<br>\n<br>\n## Important tips：\n1. 每一次在开辟新的内存的时候，都是利用修改Break指针来进行的，这也就说明，一开始，堆中是没有任何实际的内存空间映射在物理内存中的。直到我们确实有需求要在堆中开辟空间，malloc函数才通过更改break指针来把虚拟的地址段映射到物理内存中。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。\n2. 往往在释放内存的时候，都不是真正的进行释放内存，而只是更改了meta数据块（保存了malloc实际开辟数据区的一些元信息）中的free这一字段的值。从某种意义上来讲,内存是很脏的，他每次在写数据的时候都不是“擦干净在写”而是覆盖的直接写上去。\n3. 个人感觉，对内存的管理，貌似一直就是对象meta数据块这样信息的管理，类似于进程控制块，整个堆内存空间哪里能用，哪里空闲，都是通过每一块的meta数据块中的信息进行存取的，每一块中的所有信息都能够在meta数据块中的各个字段体现出来。感觉蛮方便的。\n","slug":"自己实现和malloc有关的函数","updated":1419898404000,"excerpt":"","_id":"87y8rz2bi7woe2x4","comments":true,"layout":"post","photos":[],"link":""},{"title":"Two Years With You","date":1417885602000,"categories":["n0c0eng5c2ofedd0"],"tags":["24y8g97kma62y7zc"],"descrLiption":null,"content":"<h2 id=\"2012-12-8\">2012.12.8</h2>\n<p>为了不影响你明天的生日，我提前表白了，如我所愿，我们在今天成为了一对。</p>\n<h2 id=\"2014-12-8\">2014.12.8</h2>\n<p>时间如白驹过隙，没想到，我们转眼就一起度过了两年，从大一到大三，很幸运有你的陪伴。时间越久，我总觉得我跟你说的话越来越少，但是心里却越来越离不开你。你可能不是我一生当中我最喜欢，最爱的人，但是你是对我最好的，和你一起我感觉最舒服的人。你不漂亮，但是你能无微不至的照顾我，你不聪明，但是你能宽容的包容我的一切。这就是我和你在一起的理由，它真实，看得见，摸得着。<br><br></p>\n<p>肉麻的话，在心里，实在是难说出口。我总是有一种预感，我们能走得更远。因为我们都太需要彼此了。我不再想，也不需要那些所谓的爱情和感情，我的愿望就是能找到一个能包容我，照顾我，不给我带来麻烦的那么一个人陪在我身边就足够了。我的感情似乎就是这样，平淡如水，但经得住考验。</p>\n<p>我们希望都能在最需要帮助的时候，彼此以最合适的时间和方式出现在对方的世界里，我希望这就是我们的感情，我们对以后的路的定义。</p>\n<p><br><br>多了不再说了，希望我们能够这样平静的走下去就行。感情，无所谓轰轰烈烈，只求，长久，安静，平淡。 </p>\n","source":"_posts/Two-Years-With-You.md","raw":"title: Two Years With You\ndate: 2014-12-07 01:06:42\ncategories: [Life]\ntags: [Life]\ndescrLiption: \n---\n\n\n## 2012.12.8\n为了不影响你明天的生日，我提前表白了，如我所愿，我们在今天成为了一对。\n\n## 2014.12.8\n时间如白驹过隙，没想到，我们转眼就一起度过了两年，从大一到大三，很幸运有你的陪伴。时间越久，我总觉得我跟你说的话越来越少，但是心里却越来越离不开你。你可能不是我一生当中我最喜欢，最爱的人，但是你是对我最好的，和你一起我感觉最舒服的人。你不漂亮，但是你能无微不至的照顾我，你不聪明，但是你能宽容的包容我的一切。这就是我和你在一起的理由，它真实，看得见，摸得着。\n<br>\n\n肉麻的话，在心里，实在是难说出口。我总是有一种预感，我们能走得更远。因为我们都太需要彼此了。我不再想，也不需要那些所谓的爱情和感情，我的愿望就是能找到一个能包容我，照顾我，不给我带来麻烦的那么一个人陪在我身边就足够了。我的感情似乎就是这样，平淡如水，但经得住考验。\n\n我们希望都能在最需要帮助的时候，彼此以最合适的时间和方式出现在对方的世界里，我希望这就是我们的感情，我们对以后的路的定义。\n\n<br>\n多了不再说了，希望我们能够这样平静的走下去就行。感情，无所谓轰轰烈烈，只求，长久，安静，平淡。 ","slug":"Two-Years-With-You","updated":1419898404000,"excerpt":"","_id":"00qaobvpvh6on9pr","comments":true,"layout":"post","photos":[],"link":""},{"title":"多线程相关","date":1419231596000,"categories":["1738y9s4gafvcrll"],"tags":["8u5k1qrjxmxqoj4q","uuyyus036pzw6j46"],"description":null,"content":"<h2 id=\"进程的概念\">进程的概念</h2>\n<p><br><br>计算机当中有程序，进程，线程这三个概念。程序是计算机指令集合以文件的形式存储在我们的硬盘上，比如我们长写的C语言控制台程序，最后生成的可执行文件.exe，这就是程序。<br>进程，是运行的程序，它是程序一个运行当中的实例。也就是说，一个程序可以对应与多个进程，可以对应于多个运行当中的程序实例。说白了：程序是死的，进程是活的。<br><br>程序的运行，也就是进程的运行都需要一定的系统资源来进行支撑，因为程序在运行的时候总会用到各种各样的比如内存等系统资源，系统是把这些系统资源都分配给了进程，而不是分配给了程序。因此，进程是计算机中一个独立的运行单位。</p>\n<p><br></p>\n<h2 id=\"进程的组成\">进程的组成</h2>\n<p><br><br>进程有两部分：<br></p>\n<ol>\n<li>内核对象部分: 计算机的内存都分为内核部分和用户部分。操作系统想管理进程，就必须要知道这个进程的一些参数和信息，所以在相应的内核部分要维护一个小的内存块，称为内核对象，这个对象是一个特殊的数据结构，里面存储了很多和进程相关的信息。(我认为这个内核对象就是进程控制块，PCB)<br></li>\n<li>地址空间：里面存放了数据和代码已经所有分配的动态的内存空间等等。<br><br></li>\n</ol>\n<h2 id=\"进程的执行方式\">进程的执行方式</h2>\n<p><br><br>关于进程，一直强调给自己的一点就是，进程虽然是计算机中资源分配和系统调度的单位，但是进程是不做一些实际性的工作的，进程的创建只不过是为我们提供一个大的好的执行环境，真正执行代码处理数据的，是进程里面的线程。每一个进程在创建的同时都会创建一个主线程，比如我们写控制台程序时候的main函数，都知道一个程序的开始是从main函数开始，但是执行这个main函数的不是进程本身，而是进程当中的主线程。当然，主线程就像是母细胞一样，可以创建出一些子线程，为整个进程分工而行。<br><br></p>\n<h2 id=\"进程的地址空间\">进程的地址空间</h2>\n<p><br><br>进程是比较傻的，系统为每一个进程都分配一个虚拟的内存地址空间，让每一个进程都误以为他们是计算机当中唯一一个运行的进程。A进程访问的0x123456和B进程访问0x123456，两个进程访问的地方虽然表面上看起来是一样的，但是实际上访问的是两个地方。由于分配给进程的是虚拟地址空间，那么，真正在把数据要存储到物理介质上，还需要从虚拟地址空间到物理存储设备的一个映射。但是要注意，映射的物理存储的大小包括了两个部分，一个是真正的物理内存，还有一部分就是虚拟内存，虚拟内存就是在硬盘上开辟一些空间去弥补内存速度快容量小的优点。所以，对于一般的32位的机器来说，分配给一个进程的虚拟地址空间都是4GB(2^32).<br><br></p>\n<h2 id=\"线程的概念\">线程的概念</h2>\n<p><br><br>对于线程来说，唯一要注意的就是，线程的一切活动都是在进程的地址空间中进行的。线程同样有两部分组成，一部分是内核对象，另外一部分是线程栈。PS：我还是觉得，书上说的这个所谓的内核对象其实就是线程控制块。线程栈，则是存放线程执行一些函数和代码所需要的参数和变量的地方，它主要存储在进程的地址空间内，因为进程主要就是为线程提供良好的运行环境的。并且，一个进程下面所属的线程彼此之间都是可见的，进程下面所有的线程都会对其他的线程或者说是进程控制块的一些句柄都能够正常的访问到。<br><br></p>\n<h2 id=\"线程的运行\">线程的运行</h2>\n<p><br><br>线程的调度，用的是时间片轮转的办法，频繁的进行切换，让人们误以为所有的线程都是同时在运行的，实际上，对待单核的机器来说，多线程都是并发的在运行的。(请注意：并发和并行是有区别的)。我们都知道main函数是一个程序的主线程，那么当我们在创建新的子线程的时候，也需要为这个线程指定一个函数，以便这个线程在创建之后就直接执行这个函数，但是这个函数的定义是要符合一定的要求的。</p>\n<p>一般来说，我们在创建一个新线程的时候，都是先用createthread函数先创建，之后，紧接着就用closehandle函数来关闭进程的句柄。原因是这样的，每一个线程的内核对象都有一个叫做引用计数的机制用于垃圾回收处理。当我们在创建一个新的子线程的时候，子线程在主线程中就有一个引用，此时，线程的引用计数就已经是1了，后来在线程的实际运行过程当中，引用计数还会加1，也就是说，如果我们确实对主线程对子线程的引用不感兴趣的话，最好是把它关闭，不然，当一个线程运行结束之后，虽然引用计数会减掉1，但是仍然没有减小到0，因为主线程还对子线程有着引用，所以，这个线程就只能到整个进程结束的时候才能够结束。<br><br></p>\n<h2 id=\"互斥对象\">互斥对象</h2>\n<p><br><br>由于线程都是交替进行的，并且一个进程中的多个线程都在一段共同的地址空间内，这样一来，一些共享资源可能就会因为多个线程的访问而造成混乱，为了防止这种情况，操作系统将为每一个共享且一次只能有一个线程使用的资源定义一个互斥对象，这个互斥对象就相当于门一样，一次只放进一个线程进来访问门里面的共享资源，在有多余一个线程想要使用同一个资源的时候，就会把它挡在门外，不让其他线程进来。针对互斥对象来讲，就相当于我们在操作系统中，生产者和消费者算法里面的PV操作一样。每一个互斥对象都是一个内核对象，里面维护了三个比较重要的数据，线程ID,使用数量，计数器。其中ID是哪一个线程正在使用这个互斥对象，那么这个ID就是那个线程的ID，其次，计数器就相当于PV操作里面的信号量，只不过计数器里面的数都是&gt;=0的数字。<br><br><br><br>创建了互斥对象之后，接下来就是使用和释放互斥对象，这也就是PV操作的实质。每一个共享的资源，都应该有一个相对应的互斥对象来守卫着它。每一次，当一个线程想使用这个共享资源的时候，都需要先请求这个互斥对象，注意，互斥对象和共享资源都一样，一次只能被一个线程使用，只不过互斥对象相当于一个大门一样，一次只放进来一个线程，其余的线程虽然请求使用，但是都把他们租挡在门外，只不过会记下这些调用互斥对象的线程。<br><br>具体使用的请求互斥对象的函数可能因为平台的不同而不同。当我们使用完共享资源的时候，我们也就应该释放对互斥对象的所有权，好让他放进新的线程进入共享资源的空间内进行使用。所以，在使用互斥对象保证共享资源的使用正确时，一般是这样的流程：创建互斥对象—-》使用互斥对象——————》释放互斥对象。<br><br></p>\n<h2 id=\"多线程实例\">多线程实例</h2>\n<p>结合多线程和网络变成，写了一个基于UDP协议的网络聊天室程序。<br><br><a href=\"https://github.com/fengzixu/MultiThreading-Chat-Programe\" target=\"_blank\" rel=\"external\">源码地址</a></p>\n","source":"_posts/进程的概念.md","raw":"title: 多线程相关\ndate: 2014-12-22 14:59:56\ncategories: OS\ntags: [os, 读书笔记]\ndescription:\n---\n\n\n##进程的概念\n<br>\n计算机当中有程序，进程，线程这三个概念。程序是计算机指令集合以文件的形式存储在我们的硬盘上，比如我们长写的C语言控制台程序，最后生成的可执行文件.exe，这就是程序。\n进程，是运行的程序，它是程序一个运行当中的实例。也就是说，一个程序可以对应与多个进程，可以对应于多个运行当中的程序实例。说白了：程序是死的，进程是活的。<br>\n程序的运行，也就是进程的运行都需要一定的系统资源来进行支撑，因为程序在运行的时候总会用到各种各样的比如内存等系统资源，系统是把这些系统资源都分配给了进程，而不是分配给了程序。因此，进程是计算机中一个独立的运行单位。\n\n<br>\n\n## 进程的组成\n<br>\n进程有两部分：<br>\n1. 内核对象部分: 计算机的内存都分为内核部分和用户部分。操作系统想管理进程，就必须要知道这个进程的一些参数和信息，所以在相应的内核部分要维护一个小的内存块，称为内核对象，这个对象是一个特殊的数据结构，里面存储了很多和进程相关的信息。(我认为这个内核对象就是进程控制块，PCB)<br>\n2. 地址空间：里面存放了数据和代码已经所有分配的动态的内存空间等等。\n<br>\n\n## 进程的执行方式\n<br>\n关于进程，一直强调给自己的一点就是，进程虽然是计算机中资源分配和系统调度的单位，但是进程是不做一些实际性的工作的，进程的创建只不过是为我们提供一个大的好的执行环境，真正执行代码处理数据的，是进程里面的线程。每一个进程在创建的同时都会创建一个主线程，比如我们写控制台程序时候的main函数，都知道一个程序的开始是从main函数开始，但是执行这个main函数的不是进程本身，而是进程当中的主线程。当然，主线程就像是母细胞一样，可以创建出一些子线程，为整个进程分工而行。\n<br>\n## 进程的地址空间\n<br>\n进程是比较傻的，系统为每一个进程都分配一个虚拟的内存地址空间，让每一个进程都误以为他们是计算机当中唯一一个运行的进程。A进程访问的0x123456和B进程访问0x123456，两个进程访问的地方虽然表面上看起来是一样的，但是实际上访问的是两个地方。由于分配给进程的是虚拟地址空间，那么，真正在把数据要存储到物理介质上，还需要从虚拟地址空间到物理存储设备的一个映射。但是要注意，映射的物理存储的大小包括了两个部分，一个是真正的物理内存，还有一部分就是虚拟内存，虚拟内存就是在硬盘上开辟一些空间去弥补内存速度快容量小的优点。所以，对于一般的32位的机器来说，分配给一个进程的虚拟地址空间都是4GB(2^32).\n<br>\n## 线程的概念\n<br>\n对于线程来说，唯一要注意的就是，线程的一切活动都是在进程的地址空间中进行的。线程同样有两部分组成，一部分是内核对象，另外一部分是线程栈。PS：我还是觉得，书上说的这个所谓的内核对象其实就是线程控制块。线程栈，则是存放线程执行一些函数和代码所需要的参数和变量的地方，它主要存储在进程的地址空间内，因为进程主要就是为线程提供良好的运行环境的。并且，一个进程下面所属的线程彼此之间都是可见的，进程下面所有的线程都会对其他的线程或者说是进程控制块的一些句柄都能够正常的访问到。\n<br>\n## 线程的运行\n<br>\n线程的调度，用的是时间片轮转的办法，频繁的进行切换，让人们误以为所有的线程都是同时在运行的，实际上，对待单核的机器来说，多线程都是并发的在运行的。(请注意：并发和并行是有区别的)。我们都知道main函数是一个程序的主线程，那么当我们在创建新的子线程的时候，也需要为这个线程指定一个函数，以便这个线程在创建之后就直接执行这个函数，但是这个函数的定义是要符合一定的要求的。\n\n一般来说，我们在创建一个新线程的时候，都是先用createthread函数先创建，之后，紧接着就用closehandle函数来关闭进程的句柄。原因是这样的，每一个线程的内核对象都有一个叫做引用计数的机制用于垃圾回收处理。当我们在创建一个新的子线程的时候，子线程在主线程中就有一个引用，此时，线程的引用计数就已经是1了，后来在线程的实际运行过程当中，引用计数还会加1，也就是说，如果我们确实对主线程对子线程的引用不感兴趣的话，最好是把它关闭，不然，当一个线程运行结束之后，虽然引用计数会减掉1，但是仍然没有减小到0，因为主线程还对子线程有着引用，所以，这个线程就只能到整个进程结束的时候才能够结束。\n<br>\n\n## 互斥对象\n<br>\n由于线程都是交替进行的，并且一个进程中的多个线程都在一段共同的地址空间内，这样一来，一些共享资源可能就会因为多个线程的访问而造成混乱，为了防止这种情况，操作系统将为每一个共享且一次只能有一个线程使用的资源定义一个互斥对象，这个互斥对象就相当于门一样，一次只放进一个线程进来访问门里面的共享资源，在有多余一个线程想要使用同一个资源的时候，就会把它挡在门外，不让其他线程进来。针对互斥对象来讲，就相当于我们在操作系统中，生产者和消费者算法里面的PV操作一样。每一个互斥对象都是一个内核对象，里面维护了三个比较重要的数据，线程ID,使用数量，计数器。其中ID是哪一个线程正在使用这个互斥对象，那么这个ID就是那个线程的ID，其次，计数器就相当于PV操作里面的信号量，只不过计数器里面的数都是>=0的数字。<br>\n<br>\n创建了互斥对象之后，接下来就是使用和释放互斥对象，这也就是PV操作的实质。每一个共享的资源，都应该有一个相对应的互斥对象来守卫着它。每一次，当一个线程想使用这个共享资源的时候，都需要先请求这个互斥对象，注意，互斥对象和共享资源都一样，一次只能被一个线程使用，只不过互斥对象相当于一个大门一样，一次只放进来一个线程，其余的线程虽然请求使用，但是都把他们租挡在门外，只不过会记下这些调用互斥对象的线程。<br>\n具体使用的请求互斥对象的函数可能因为平台的不同而不同。当我们使用完共享资源的时候，我们也就应该释放对互斥对象的所有权，好让他放进新的线程进入共享资源的空间内进行使用。所以，在使用互斥对象保证共享资源的使用正确时，一般是这样的流程：创建互斥对象---》使用互斥对象——————》释放互斥对象。\n<br>\n\n## 多线程实例\n结合多线程和网络变成，写了一个基于UDP协议的网络聊天室程序。<br>\n[源码地址](https://github.com/fengzixu/MultiThreading-Chat-Programe)\n\n","slug":"进程的概念","updated":1419898404000,"excerpt":"","_id":"v42oi49bn9bbqzi5","comments":true,"layout":"post","photos":[],"link":""},{"title":"乘法溢出和加法溢出的判断","date":1417526576000,"categories":["vui64jezcwp8fefa"],"tags":["8u5k1qrjxmxqoj4q","3deavz2yda18qn81","uuyyus036pzw6j46"],"description":null,"content":"<h1 id=\"乘法溢出和加法溢出的判断\">乘法溢出和加法溢出的判断</h1>\n<p><br></p>\n<blockquote>\n<p>根据CSAPP中补码和无符号数计算章节的提炼</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"溢出的缘由\">溢出的缘由</h2>\n<p>C语言当中的数据类型，有无符号整数，也有有符号的整数，有符号的整数通常在计算机中都是用补码来表示的。首先，计算机承认的数据类型只有一种，就是二进制串，那么，不管一个数最后被解释成是有符号数还是无符号数，那么这个数在内存中的位模式是不变的，所以两个不同或者相同的位模式相加的话，所得到的位模式也是不变的。这也就是为什么，对于无符号数和有符号数的计算都可以统一用一种规则。</p>\n<p>对于无论是加法还是乘法这种算数运算来说，都存在着运算结构溢出这种现象的发生，什么叫溢出，如果我理解，就是我们算出来的数值结果，计算机已经不能够准确完全的表示了，如果出现计算结果的数据长度大于计算机的字长的话，那么就需要进行数据截断操作，一旦发生了截断操作，那么我们的真实结果就会发生变动，这种情况就是溢出。<br><br></p>\n<h2 id=\"无符号数加法的溢出\">无符号数加法的溢出</h2>\n<p>例如，一个四位的二进制串。如果现在一个无符号数1111+0111=10110。如果说现在计算机的子长只有4的话，那么肯定存不下这5位二进制的结果，这样就会截断溢出的那一位，编程0110.原来的无符号数的加法是15+7=22.四位二进制数的无符号数的取值范围为0~15.本来的真实结果是22，因为溢出的原因变成了6.我们发现，运算结果出来之后把最高位，也就是从右向左的第五位舍去了，那么这就在我们原来的运算结果中减掉了2^4.所以说结果从22变为了6。<br><br><br>这一个例子也就告诉了我们在计算机中，我们所做的无符号数的加法运算是模2^k的运算，其中k是计算机的机器字长。<br><br></p>\n<h2 id=\"判断无符号数的溢出\">判断无符号数的溢出</h2>\n<p>如果是无符号数的话。s=x+y，没有溢出时肯定是s&gt;x+y。如果一旦有了溢出的话，那么x&gt;s||y&gt;s。<br>例如，如果计算溢出s=x+y-2^k,假设2^k&gt;y，那么x+y-2^k<x，则s<x <br=\"\"></x，则s<x></p>\n<h2 id=\"补码加法的溢出\">补码加法的溢出</h2>\n<p>前面已经提到过，同一个二进制串可以被解释成一个补码一个无符号数。那么虽然我们看起来两者是由区别的，但是在位模式上，在针对位模式的运算上面，两者并没有什么不同，因为都是对同一个位模式进行操作，只不过最后可以被解释称无符号数和有符号数。</p>\n<h3 id=\"补码的运算规则\">补码的运算规则</h3>\n<p>既然无符号数和补码都能够表示成同一个位模式的话，那么加法的运算规则也就比较统一———-在计算补码的加法的时候，例如：0111+1001，可以先把这两个位模式看成无符号数，根据无符号数的规则进行相加结果为10000，然后要进行截断操作结果为0000.最后把无符号数已经截断的运算结果解释称为补码（也就是从无符号数到有符号数的转换），就是补码运算最后的结果。</p>\n<blockquote>\n<p>之所以可以这么做，就是使用了，两个数的w位的补码和无符号数可能有相同的位模式这一特点。</p>\n</blockquote>\n<h3 id=\"溢出\">溢出</h3>\n<p>因为是有符号数，也就是补码，溢出的种类也分两种，正溢出和负溢出。</p>\n<ol>\n<li>正溢出，是因为计算的结果在未截断之前大于规定位数所能表示的最大值，在模2^k的时候，就要在原来的无符号数的结果上相应的减掉2^k。</li>\n<li>负溢出，是因为计算结果在未截断之前，小于我们所规定位数能够表示的最小值，在模2^k的时候就要相应的加上2^k。</li>\n</ol>\n<p>总之，在处理正溢出还有负溢出的时候，都是想把超出我们能够表示的结果修正成我们能够表示的结果。</p>\n<p><br></p>\n<h2 id=\"判断补码加法的溢出\">判断补码加法的溢出</h2>\n<p>有一些基本的运算常识我觉得都会对运算有以下几个认识：</p>\n<ol>\n<li>一个正数一个负数(前提是合法的),相加绝对不会出现溢出</li>\n<li>两个正数相加可能溢出最后得到0或者一个负数</li>\n<li>两个负数相加可能溢出最后得到一个正数</li>\n</ol>\n<p>所以说，根据上面这些常识，我们完全就能够判断出补码的加法的溢出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">flag1 = x&lt;<span class=\"number\">0</span>&&y&lt;<span class=\"number\">0</span>&&(x+y)&gt;<span class=\"number\">0</span>;</div><div class=\"line\">flag2 = x&gt;<span class=\"number\">0</span>&&y&gt;<span class=\"number\">0</span>&&(x+y)&lt;=<span class=\"number\">0</span>;</div><div class=\"line\"><span class=\"keyword\">return</span> !flag1&&(!flag2);</div></pre></td></tr></table></figure>\n\n<p>这个程序的道理很简单，都是计算的时候，我们理想的结果和我们实际的结果是不匹配的，仔细想想，两个正数相加最后得到0或者负数这明显不正常，肯定是计算之中出了问题么。<br><br></p>\n<h2 id=\"无符号数的乘法和有符号数的乘法\">无符号数的乘法和有符号数的乘法</h2>\n<p>无符号数的乘法几乎和加法的处理办法一样，都是在算得结果之后，如果结果的长度超出计算机的字长，那么就进行模2^k的操作，即把结果“瘦身”，放进字节为2^k的空间内。有符号数的乘法运算也是仿照，有符号数的加法运算的处理办法一样，因为一个位模式可能会生成一个补码序列一个无符号数序列，两者可能在数值上是不同的，但是在位模式下是绝对相同的。利用这一特点，在计算补码乘法的时候，继续把这些位模式当作无符号数进行乘法运算，最后把进行截断操作的结果再解释为有符号数的补码。</p>\n<blockquote>\n<p>比较重要的一点是，虽然补码和无符号数相乘的结果，在未截断之前的位模式可能是不一样的，但是一旦在规范之后，也就是在截断之后，两者的位模式是肯定会相同的。</p>\n</blockquote>\n<p>比如，我的计算机字长有3位，要计算101和011的乘法：</p>\n<table>\n<thead>\n<tr>\n<th>种类</th>\n<th style=\"text-align:center\">乘数</th>\n<th style=\"text-align:right\">被乘数</th>\n<th style=\"text-align:right\">未截断</th>\n<th style=\"text-align:right\">截断后</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>有符号</td>\n<td style=\"text-align:center\">101（5）</td>\n<td style=\"text-align:right\">011(3)</td>\n<td style=\"text-align:right\">001111(15)</td>\n<td style=\"text-align:right\">111(7)</td>\n</tr>\n<tr>\n<td>无符号</td>\n<td style=\"text-align:center\">011(3)</td>\n<td style=\"text-align:right\">011(3)</td>\n<td style=\"text-align:right\">110111(-9）</td>\n<td style=\"text-align:right\">111(-1)</td>\n</tr>\n</tbody>\n</table>\n<p>根据上面的例子可以看出有符号数相乘的结果和无符号数相乘的结果在截断后都是相同的，只不过是把位模式解释成了补码或者无符号数。并不要在意没有截断之前的位模式，因为真正在计算机中是不会出现这种位模式的中间计算结果的。</p>\n<h2 id=\"判断乘法溢出\">判断乘法溢出</h2>\n<p>判断乘法运算结果的溢出有两种办法，第一种是利用除法来判定，比较麻烦。还有一种比较简单。例如，如果两个w位的数相乘，那么结果最多占2w位。所以说，普通32位数的乘法，可以把两个乘数分别转换为64位的long long型来进行计算，这样的话，也只是对原来的数进行位扩展，所得的64位结果再转换为int类型，看和实际上两个32位乘数相乘计算（截断后）的结果是不是相同，如果相同，那么当然就是没有任何溢出。</p>\n","source":"_posts/乘法溢出和加法溢出的判断.md","raw":"title: 乘法溢出和加法溢出的判断\ndate: 2014-12-02 21:22:56\ncategories: CSAPP\ntags: [os, csapp, 读书笔记]\ndescription:\n---\n\n# 乘法溢出和加法溢出的判断\n<br>\n\n> 根据CSAPP中补码和无符号数计算章节的提炼\n\n<br>\n## 溢出的缘由\nC语言当中的数据类型，有无符号整数，也有有符号的整数，有符号的整数通常在计算机中都是用补码来表示的。首先，计算机承认的数据类型只有一种，就是二进制串，那么，不管一个数最后被解释成是有符号数还是无符号数，那么这个数在内存中的位模式是不变的，所以两个不同或者相同的位模式相加的话，所得到的位模式也是不变的。这也就是为什么，对于无符号数和有符号数的计算都可以统一用一种规则。\n\n对于无论是加法还是乘法这种算数运算来说，都存在着运算结构溢出这种现象的发生，什么叫溢出，如果我理解，就是我们算出来的数值结果，计算机已经不能够准确完全的表示了，如果出现计算结果的数据长度大于计算机的字长的话，那么就需要进行数据截断操作，一旦发生了截断操作，那么我们的真实结果就会发生变动，这种情况就是溢出。\n<br>\n## 无符号数加法的溢出\n例如，一个四位的二进制串。如果现在一个无符号数1111+0111=10110。如果说现在计算机的子长只有4的话，那么肯定存不下这5位二进制的结果，这样就会截断溢出的那一位，编程0110.原来的无符号数的加法是15+7=22.四位二进制数的无符号数的取值范围为0~15.本来的真实结果是22，因为溢出的原因变成了6.我们发现，运算结果出来之后把最高位，也就是从右向左的第五位舍去了，那么这就在我们原来的运算结果中减掉了2^4.所以说结果从22变为了6。\n<br>\n这一个例子也就告诉了我们在计算机中，我们所做的无符号数的加法运算是模2^k的运算，其中k是计算机的机器字长。\n<br>\n## 判断无符号数的溢出\n如果是无符号数的话。s=x+y，没有溢出时肯定是s>x+y。如果一旦有了溢出的话，那么x>s||y>s。\n例如，如果计算溢出s=x+y-2^k,假设2^k>y，那么x+y-2^k<x，则s<x\n<br>\n\n## 补码加法的溢出\n前面已经提到过，同一个二进制串可以被解释成一个补码一个无符号数。那么虽然我们看起来两者是由区别的，但是在位模式上，在针对位模式的运算上面，两者并没有什么不同，因为都是对同一个位模式进行操作，只不过最后可以被解释称无符号数和有符号数。\n\n### 补码的运算规则\n既然无符号数和补码都能够表示成同一个位模式的话，那么加法的运算规则也就比较统一-------在计算补码的加法的时候，例如：0111+1001，可以先把这两个位模式看成无符号数，根据无符号数的规则进行相加结果为10000，然后要进行截断操作结果为0000.最后把无符号数已经截断的运算结果解释称为补码（也就是从无符号数到有符号数的转换），就是补码运算最后的结果。\n\n> 之所以可以这么做，就是使用了，两个数的w位的补码和无符号数可能有相同的位模式这一特点。\n\n### 溢出\n因为是有符号数，也就是补码，溢出的种类也分两种，正溢出和负溢出。\n1. 正溢出，是因为计算的结果在未截断之前大于规定位数所能表示的最大值，在模2^k的时候，就要在原来的无符号数的结果上相应的减掉2^k。\n2. 负溢出，是因为计算结果在未截断之前，小于我们所规定位数能够表示的最小值，在模2^k的时候就要相应的加上2^k。\n\n总之，在处理正溢出还有负溢出的时候，都是想把超出我们能够表示的结果修正成我们能够表示的结果。\n\n<br>\n\n## 判断补码加法的溢出\n\n有一些基本的运算常识我觉得都会对运算有以下几个认识：\n1. 一个正数一个负数(前提是合法的),相加绝对不会出现溢出\n2. 两个正数相加可能溢出最后得到0或者一个负数\n3. 两个负数相加可能溢出最后得到一个正数\n\n所以说，根据上面这些常识，我们完全就能够判断出补码的加法的溢出：\n```c\nflag1 = x<0&&y<0&&(x+y)>0;\nflag2 = x>0&&y>0&&(x+y)<=0;\nreturn !flag1&&(!flag2);\n```\n这个程序的道理很简单，都是计算的时候，我们理想的结果和我们实际的结果是不匹配的，仔细想想，两个正数相加最后得到0或者负数这明显不正常，肯定是计算之中出了问题么。\n<br>\n\n## 无符号数的乘法和有符号数的乘法\n\n无符号数的乘法几乎和加法的处理办法一样，都是在算得结果之后，如果结果的长度超出计算机的字长，那么就进行模2^k的操作，即把结果“瘦身”，放进字节为2^k的空间内。有符号数的乘法运算也是仿照，有符号数的加法运算的处理办法一样，因为一个位模式可能会生成一个补码序列一个无符号数序列，两者可能在数值上是不同的，但是在位模式下是绝对相同的。利用这一特点，在计算补码乘法的时候，继续把这些位模式当作无符号数进行乘法运算，最后把进行截断操作的结果再解释为有符号数的补码。\n\n> 比较重要的一点是，虽然补码和无符号数相乘的结果，在未截断之前的位模式可能是不一样的，但是一旦在规范之后，也就是在截断之后，两者的位模式是肯定会相同的。\n\n比如，我的计算机字长有3位，要计算101和011的乘法：\n\n\n\n| 种类           |乘数           | 被乘数 |未截断     |截断后 |\n| -------------  |:-------------:|  -----:|-----:     |-----: |\n| 有符号         | 101（5）      |011(3)  | 001111(15)|111(7) |\n| 无符号         | 011(3)        | 011(3) |110111(-9）|111(-1)|\n\n\n根据上面的例子可以看出有符号数相乘的结果和无符号数相乘的结果在截断后都是相同的，只不过是把位模式解释成了补码或者无符号数。并不要在意没有截断之前的位模式，因为真正在计算机中是不会出现这种位模式的中间计算结果的。\n\n## 判断乘法溢出\n\n判断乘法运算结果的溢出有两种办法，第一种是利用除法来判定，比较麻烦。还有一种比较简单。例如，如果两个w位的数相乘，那么结果最多占2w位。所以说，普通32位数的乘法，可以把两个乘数分别转换为64位的long long型来进行计算，这样的话，也只是对原来的数进行位扩展，所得的64位结果再转换为int类型，看和实际上两个32位乘数相乘计算（截断后）的结果是不是相同，如果相同，那么当然就是没有任何溢出。\n\n\n\n\n","slug":"乘法溢出和加法溢出的判断","updated":1419898404000,"excerpt":"","_id":"0lgbbh81pebd64e5","comments":true,"layout":"post","photos":[],"link":""},{"title":"初探Windows网络编程","date":1417008010000,"categories":["8512ljrmz0he6ybp"],"tags":["rih0ekzximdfg7de"],"description":null,"content":"<h1 id=\"初探网络编程\">初探网络编程</h1>\n<blockquote>\n<p>也是为了写键盘记录的那个项目吧，准备把网络编程和多线程还有Hook趁着最近课少全都看了。没想到，哎，真是一拖再拖，各种事打断我。周二开始写，到今天才写了个网络编程的部分。看了看有关socket编程的知识吧，根绝TCP和UDP协议写了两个小例子。(PS:教我们计算机网络的老师烂的一逼，讲TCP三次握手的时候，我都没认真听，这块遇到了些，期末之前我还得自己把书啃一遍)。以及一个UDP的网络聊天程序，不过现在只能是实现1v1,并且是分客户端和服务端的，服务端在不接受到客户端的请求的时候，是不能主动给客户端发送信息的。这就很蛋疼啊，不能实现动态加入聊天者的地址信息，多对多的聊天形式估计也得用多线程才行。呼呼，这周继续写。</p>\n</blockquote>\n<p><br></p>\n<h2 id=\"基于TCP协议的socket程序\">基于TCP协议的socket程序</h2>\n<p><br></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">名称：基于TCP协议的网络编程的服务器端程序</div><div class=\"line\">时间：2014、11、25</div><div class=\"line\">作者：fengzixu</div><div class=\"line\">简介:</div><div class=\"line\">总体来讲就是根据TCP的socket编程写一个服务器和客户端的程序然后运行在本地。</div><div class=\"line\">关于服务器端的程序，整个过程中需要用到两个套接字，一个是监听套接字，还有一个是连接套接字。</div><div class=\"line\">监听套接字从创建开始一直到服务器程序没有终止的之前，都是存在的，而且没有关闭过。因为他要时时刻刻监听客户端的要求。但是</div><div class=\"line\">连接套接字主要是用于和客户端建立连接，然后进行通信，这样一来，每次客户端的不同请求都会造成连接套接字关闭和打开，甚至是有不同的</div><div class=\"line\">客户端依次和服务器端进行通信。</div><div class=\"line\">在给socketaddr_in对象的成员赋值的时候，出了family成员不需要强制使用网络字节顺序，其他的都需要。</div><div class=\"line\">过程很简单，比较容易理解，主要是一些细节和API不熟悉，不过慢慢用了应该还好。</div><div class=\"line\">1.初始化套接字库</div><div class=\"line\">2.创建套接字</div><div class=\"line\">3.绑定端口</div><div class=\"line\">4.开始监听</div><div class=\"line\">5.接受请求，建立连接</div><div class=\"line\">6.处理请求，发送回应</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;stdio.h&gt;</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;WinSock2.h&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main()</div><div class=\"line\">{</div><div class=\"line\">\tWORD wVerionRequested = MAKEWORD(<span class=\"number\">1</span>,<span class=\"number\">1</span>);\t\t\t<span class=\"comment\">//指定加载的套接字动态库的版本，保存相应的版本号</span></div><div class=\"line\">\tWSADATA wsadata;\t\t\t\t\t\t\t\t<span class=\"comment\">//加载的有关套接字的版本库的信息都会存在这个结构体里面</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> start = WSAStartup(wVerionRequested, &wsadata);             <span class=\"comment\">//加载套接字动态库</span></div><div class=\"line\">\t<span class=\"keyword\">if</span>(start != <span class=\"number\">0</span>)\t\t\t\t\t\t\t\t\t<span class=\"comment\">//如果成功的话，那么返回值为0</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(LOBYTE(wsadata.wVersion)!=<span class=\"number\">1</span> || HIBYTE(wsadata.wVersion)!=<span class=\"number\">1</span>)       <span class=\"comment\">//wVersion数据成员中的高位部分表示了套接字库的副版本，低位部分表示了套接字库的主版本，检查是否是我们需要的版本号</span></div><div class=\"line\">\t{</div><div class=\"line\">\t\tWSACleanup();\t<span class=\"comment\">//如果不是就要释放套接字库分配给此进程的资源</span></div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t}</div><div class=\"line\">\tSOCKET server_socket = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);    <span class=\"comment\">//创建一个套接字</span></div><div class=\"line\"></div><div class=\"line\">\tSOCKADDR_IN addrsrv;\t\t\t<span class=\"comment\">//bind函数要绑定信息，需要用到一个结构体，里面存放本地地址的信息，他根据使用的TCP协议而变为SOCKADDR_IN类型</span></div><div class=\"line\">\taddrsrv.sin_family = AF_INET;</div><div class=\"line\">\taddrsrv.sin_port = htons(<span class=\"number\">6000</span>);\t\t\t\t<span class=\"comment\">//指定要分配给这个套接字的端口</span></div><div class=\"line\">\taddrsrv.sin_addr.S_un.S_addr = INADDR_ANY;\t\t<span class=\"comment\">//指定本机的ip地址</span></div><div class=\"line\">\tbind(server_socket, (SOCKADDR *)&addrsrv, <span class=\"keyword\">sizeof</span>(SOCKADDR));</div><div class=\"line\">\tlisten(server_socket,<span class=\"number\">10</span>);\t\t\t\t\t<span class=\"comment\">//监听此端口</span></div><div class=\"line\">\tSOCKADDR_IN buffptr;\t\t\t\t\t\t<span class=\"comment\">//创建一个结构体，用于接收客户端发来请求的时候，携带的客户端的地址信息，IP和端口号等</span></div><div class=\"line\">\t<span class=\"keyword\">int</span> bufflen = <span class=\"keyword\">sizeof</span>(SOCKADDR);</div><div class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>)</div><div class=\"line\">\t{</div><div class=\"line\">\t\tSOCKET accept_socket = accept(server_socket,(SOCKADDR*)&buffptr,&bufflen);\t\t<span class=\"comment\">//开始不断的接受客户端请求的到来</span></div><div class=\"line\">\t\t<span class=\"keyword\">char</span> sendbuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//发送缓冲区</span></div><div class=\"line\">\t\t<span class=\"keyword\">char</span> recivebuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//接收缓冲区</span></div><div class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(sendbuff,<span class=\"string\">\"welcome %s to www.fengzixu.net\"</span>,inet_ntoa(buffptr.sin_addr));\t\t\t\t\t<span class=\"comment\">//把我需要的信息写入到发送缓冲区，利用inet_ntoa函数将buffptr指向的存储客户端地址信息结构体中的sin_addr转换为点分十进制的字符串</span></div><div class=\"line\">\t\tsend(accept_socket,sendbuff,<span class=\"keyword\">sizeof</span>(sendbuff)+<span class=\"number\">1</span>,<span class=\"number\">0</span>);\t\t\t\t\t<span class=\"comment\">//之所以+1是因为发送一个字符数组过去之后一定要在最后留有一个\\0字符的位置</span></div><div class=\"line\">\t\trecv(accept_socket,recivebuff,<span class=\"keyword\">sizeof</span>(recivebuff),<span class=\"number\">0</span>);</div><div class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,recivebuff);</div><div class=\"line\">\t\tclosesocket(accept_socket);\t\t\t\t\t<span class=\"comment\">//本次处理请求结束，释放为此次请求所分配的资源，关闭连接套接字。</span></div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">名称：基于TCP协议的网络编程的客户端程序</div><div class=\"line\">时间：2014、11、25</div><div class=\"line\">作者：fengzixu</div><div class=\"line\">简介：</div><div class=\"line\">在客户端程序中，只需要用一个套接字就可以完成通信功能。因为他不用绑定和监听端口，在向服务器发送请求的时候，就会携带端口和IP地址信息。</div><div class=\"line\">客户端在发送了连接请求之后，会首先收到一条服务器端发回的连接成功的信息，然后正式进入通讯阶段.</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;stdio.h&gt;</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;WinSock2.h&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main()</div><div class=\"line\">{</div><div class=\"line\">\tWORD wVersionRequested;</div><div class=\"line\">\tWSADATA wsdata;</div><div class=\"line\"></div><div class=\"line\">\twVersionRequested = MAKEWORD(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</div><div class=\"line\">\t<span class=\"keyword\">int</span> result = WSAStartup(wVersionRequested,&wsdata);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(result != <span class=\"number\">0</span>)</div><div class=\"line\">\t{</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"keyword\">if</span>(LOBYTE(wsdata.wVersion) != <span class=\"number\">1</span> || HIBYTE(wsdata.wVersion) != <span class=\"number\">1</span>)</div><div class=\"line\">\t{</div><div class=\"line\">\t\tWSACleanup();</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t}</div><div class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"number\">1</span>){</div><div class=\"line\">\tSOCKET connect_socket = socket(AF_INET,SOCK_STREAM,<span class=\"number\">0</span>);</div><div class=\"line\">\tsockaddr_in sockad;</div><div class=\"line\">\tsockad.sin_family = AF_INET;</div><div class=\"line\">\tsockad.sin_port = htons(<span class=\"number\">6000</span>);</div><div class=\"line\">\tsockad.sin_addr.S_un.S_addr = inet_addr(<span class=\"string\">\"125.221.225.14\"</span>);</div><div class=\"line\">\t<span class=\"comment\">//connect(connect_socket,(sockaddr*)&sockad,sizeof(SOCKADDR));</span></div><div class=\"line\">\tconnect(connect_socket,(sockaddr*)&sockad,<span class=\"keyword\">sizeof</span>(SOCKADDR));</div><div class=\"line\">\t<span class=\"keyword\">char</span> sendbuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};</div><div class=\"line\">\t<span class=\"keyword\">char</span> recivebuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};</div><div class=\"line\">\trecv(connect_socket,recivebuff,<span class=\"keyword\">sizeof</span>(recivebuff),<span class=\"number\">0</span>);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,recivebuff);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"input your message: \"</span>);</div><div class=\"line\">\tgets(sendbuff);</div><div class=\"line\">\tsend(connect_socket,sendbuff,<span class=\"keyword\">sizeof</span>(sendbuff)+<span class=\"number\">1</span>,<span class=\"number\">0</span>);</div><div class=\"line\">\tclosesocket(connect_socket);</div><div class=\"line\">\t}</div><div class=\"line\">\tWSACleanup();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<h2 id=\"基于UDP协议的Socket程序\">基于UDP协议的Socket程序</h2>\n<p><br></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//客户端</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;stdio.h&gt;</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;WinSock2.h&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main()</div><div class=\"line\">{</div><div class=\"line\">\tWORD wVersionRequested = MAKEWORD(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</div><div class=\"line\">\tWSAData wsdata;</div><div class=\"line\">\t<span class=\"keyword\">int</span> flag = WSAStartup(wVersionRequested,&wsdata);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(flag != <span class=\"number\">0</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(HIBYTE(wsdata.wVersion) != <span class=\"number\">1</span> || LOBYTE(wsdata.wVersion) != <span class=\"number\">1</span>)</div><div class=\"line\">\t{</div><div class=\"line\">\t\tWSACleanup();</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t}</div><div class=\"line\"></div><div class=\"line\">\tSOCKET client_socket = socket(AF_INET,SOCK_DGRAM,<span class=\"number\">0</span>);</div><div class=\"line\">\t<span class=\"keyword\">char</span> sendbuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};</div><div class=\"line\">\tsockaddr_in clientadd;</div><div class=\"line\">\tclientadd.sin_family = AF_INET;</div><div class=\"line\">\tclientadd.sin_port=htons(<span class=\"number\">6000</span>);</div><div class=\"line\">\tclientadd.sin_addr.S_un.S_addr = inet_addr(<span class=\"string\">\"125.221.225.14\"</span>);</div><div class=\"line\">\tgets(sendbuff);</div><div class=\"line\">\tsendto(client_socket,sendbuff,<span class=\"keyword\">sizeof</span>(sendbuff),<span class=\"number\">0</span>,(SOCKADDR*)&clientadd,<span class=\"keyword\">sizeof</span>(sockaddr_in));</div><div class=\"line\">\tclosesocket(client_socket);</div><div class=\"line\">\tWSACleanup();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//服务器端</span></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">名称：基于UDP协议的服务端程序</div><div class=\"line\">作者： fengzixu</div><div class=\"line\">时间: 2014/11/25</div><div class=\"line\">简介：</div><div class=\"line\">基于UDP和TCP两个协议的不同版本，大致的框架都是相同的，只是有几处细节不同。</div><div class=\"line\">首先，基于TCP协议的服务端，需要两个套接字，一个用来绑定端口并且监听，一个用来建立连接。</div><div class=\"line\">但是UDP协议中不需要监听和建立连接，绑定端口之后直接就可以通信，且从始至终只用一个套接字(在创建套接字的时候，TCP和UDP的类型是不一样的)</div><div class=\"line\">其次，就是接受信息的API不同。TCP是recv而UDP是recvfrom</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;stdio.h&gt;</span></div><div class=\"line\"><span class=\"preprocessor\">#<span class=\"keyword\">include</span>&lt;WinSock2.h&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> main()</div><div class=\"line\">{</div><div class=\"line\">\tWORD wVersionRequested = MAKEWORD(<span class=\"number\">1</span>,<span class=\"number\">1</span>);</div><div class=\"line\">\tWSAData wsdata;</div><div class=\"line\">\t<span class=\"keyword\">int</span> flag = WSAStartup(wVersionRequested,&wsdata);</div><div class=\"line\">\t<span class=\"keyword\">if</span>(flag != <span class=\"number\">0</span>)</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(HIBYTE(wsdata.wVersion) != <span class=\"number\">1</span> || LOBYTE(wsdata.wVersion) != <span class=\"number\">1</span>)</div><div class=\"line\">\t{</div><div class=\"line\">\t\tWSACleanup();</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">\t}</div><div class=\"line\"></div><div class=\"line\">\tSOCKET server_socket = socket(AF_INET,SOCK_DGRAM,<span class=\"number\">0</span>);</div><div class=\"line\">\tsockaddr_in sockadd;</div><div class=\"line\">\tsockadd.sin_family = AF_INET;</div><div class=\"line\">\tsockadd.sin_port = htons(<span class=\"number\">6000</span>);</div><div class=\"line\">\tsockadd.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</div><div class=\"line\"></div><div class=\"line\">\tbind(server_socket, (SOCKADDR*)&sockadd,<span class=\"keyword\">sizeof</span>(SOCKADDR));</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">char</span> recivebuff[<span class=\"number\">1000</span>] = {<span class=\"number\">0</span>};</div><div class=\"line\">\tsockaddr_in clientaddr;</div><div class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"keyword\">sizeof</span>(clientaddr);</div><div class=\"line\">\trecvfrom(server_socket,recivebuff,<span class=\"keyword\">sizeof</span>(recivebuff),<span class=\"number\">0</span>,(SOCKADDR*)&clientaddr,&len);</div><div class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,recivebuff);</div><div class=\"line\">\tclosesocket(server_socket);</div><div class=\"line\">\tWSACleanup();</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">}</div></pre></td></tr></table></figure>\n\n<p><br></p>\n<h2 id=\"基于UDP协议的网络聊天程序\">基于UDP协议的网络聊天程序</h2>\n<h3 id=\"源码，戳我\"><a href=\"https://github.com/fengzixu/SocketTestPrograme/tree/master/UDPSocketTalkPrograme\" target=\"_blank\" rel=\"external\">源码，戳我</a></h3>\n<p><br></p>\n<h2 id=\"所有程序的源码\">所有程序的源码</h2>\n<h3 id=\"Click_it\"><a href=\"https://github.com/fengzixu/SocketTestPrograme\" target=\"_blank\" rel=\"external\">Click it</a></h3>\n","source":"_posts/初探Windows网络编程.md","raw":"title: 初探Windows网络编程\ndate: 2014-11-26 21:20:10\ncategories: [Windows]\ntags: [Windows socket]\ndescription:\n---\n\n# 初探网络编程\n\n> 也是为了写键盘记录的那个项目吧，准备把网络编程和多线程还有Hook趁着最近课少全都看了。没想到，哎，真是一拖再拖，各种事打断我。周二开始写，到今天才写了个网络编程的部分。看了看有关socket编程的知识吧，根绝TCP和UDP协议写了两个小例子。(PS:教我们计算机网络的老师烂的一逼，讲TCP三次握手的时候，我都没认真听，这块遇到了些，期末之前我还得自己把书啃一遍)。以及一个UDP的网络聊天程序，不过现在只能是实现1v1,并且是分客户端和服务端的，服务端在不接受到客户端的请求的时候，是不能主动给客户端发送信息的。这就很蛋疼啊，不能实现动态加入聊天者的地址信息，多对多的聊天形式估计也得用多线程才行。呼呼，这周继续写。\n\n\n\n<br>\n## 基于TCP协议的socket程序\n<br>\n```c\n/*\n名称：基于TCP协议的网络编程的服务器端程序\n时间：2014、11、25\n作者：fengzixu\n简介:\n总体来讲就是根据TCP的socket编程写一个服务器和客户端的程序然后运行在本地。\n关于服务器端的程序，整个过程中需要用到两个套接字，一个是监听套接字，还有一个是连接套接字。\n监听套接字从创建开始一直到服务器程序没有终止的之前，都是存在的，而且没有关闭过。因为他要时时刻刻监听客户端的要求。但是\n连接套接字主要是用于和客户端建立连接，然后进行通信，这样一来，每次客户端的不同请求都会造成连接套接字关闭和打开，甚至是有不同的\n客户端依次和服务器端进行通信。\n在给socketaddr_in对象的成员赋值的时候，出了family成员不需要强制使用网络字节顺序，其他的都需要。\n过程很简单，比较容易理解，主要是一些细节和API不熟悉，不过慢慢用了应该还好。\n1.初始化套接字库\n2.创建套接字\n3.绑定端口\n4.开始监听\n5.接受请求，建立连接\n6.处理请求，发送回应\n*/\n\n\n\n\n#include<stdio.h>\n#include<WinSock2.h>\n\nint main()\n{\n\tWORD wVerionRequested = MAKEWORD(1,1);\t\t\t//指定加载的套接字动态库的版本，保存相应的版本号\n\tWSADATA wsadata;\t\t\t\t\t\t\t\t//加载的有关套接字的版本库的信息都会存在这个结构体里面\n\tint start = WSAStartup(wVerionRequested, &wsadata);             //加载套接字动态库\n\tif(start != 0)\t\t\t\t\t\t\t\t\t//如果成功的话，那么返回值为0\n\t\treturn 0;\n\tif(LOBYTE(wsadata.wVersion)!=1 || HIBYTE(wsadata.wVersion)!=1)       //wVersion数据成员中的高位部分表示了套接字库的副版本，低位部分表示了套接字库的主版本，检查是否是我们需要的版本号\n\t{\n\t\tWSACleanup();\t//如果不是就要释放套接字库分配给此进程的资源\n\t\treturn 0;\n\t}\n\tSOCKET server_socket = socket(AF_INET,SOCK_STREAM,0);    //创建一个套接字\n\n\tSOCKADDR_IN addrsrv;\t\t\t//bind函数要绑定信息，需要用到一个结构体，里面存放本地地址的信息，他根据使用的TCP协议而变为SOCKADDR_IN类型\n\taddrsrv.sin_family = AF_INET;\n\taddrsrv.sin_port = htons(6000);\t\t\t\t//指定要分配给这个套接字的端口\n\taddrsrv.sin_addr.S_un.S_addr = INADDR_ANY;\t\t//指定本机的ip地址\n\tbind(server_socket, (SOCKADDR *)&addrsrv, sizeof(SOCKADDR));\n\tlisten(server_socket,10);\t\t\t\t\t//监听此端口\n\tSOCKADDR_IN buffptr;\t\t\t\t\t\t//创建一个结构体，用于接收客户端发来请求的时候，携带的客户端的地址信息，IP和端口号等\n\tint bufflen = sizeof(SOCKADDR);\n\twhile(1)\n\t{\n\t\tSOCKET accept_socket = accept(server_socket,(SOCKADDR*)&buffptr,&bufflen);\t\t//开始不断的接受客户端请求的到来\n\t\tchar sendbuff[1000] = {0};\t\t\t\t\t\t\t\t\t\t\t\t\t\t//发送缓冲区\n\t\tchar recivebuff[1000] = {0};\t\t\t\t\t\t\t\t\t\t\t\t\t//接收缓冲区\n\t\tsprintf(sendbuff,\"welcome %s to www.fengzixu.net\",inet_ntoa(buffptr.sin_addr));\t\t\t\t\t//把我需要的信息写入到发送缓冲区，利用inet_ntoa函数将buffptr指向的存储客户端地址信息结构体中的sin_addr转换为点分十进制的字符串\n\t\tsend(accept_socket,sendbuff,sizeof(sendbuff)+1,0);\t\t\t\t\t//之所以+1是因为发送一个字符数组过去之后一定要在最后留有一个\\0字符的位置\n\t\trecv(accept_socket,recivebuff,sizeof(recivebuff),0);\n\t\tprintf(\"%s\\n\",recivebuff);\n\t\tclosesocket(accept_socket);\t\t\t\t\t//本次处理请求结束，释放为此次请求所分配的资源，关闭连接套接字。\n\t}\n\treturn 0;\n}\n\n\n\n\n/*\n名称：基于TCP协议的网络编程的客户端程序\n时间：2014、11、25\n作者：fengzixu\n简介：\n在客户端程序中，只需要用一个套接字就可以完成通信功能。因为他不用绑定和监听端口，在向服务器发送请求的时候，就会携带端口和IP地址信息。\n客户端在发送了连接请求之后，会首先收到一条服务器端发回的连接成功的信息，然后正式进入通讯阶段.\n*/\n\n\n\n#include<stdio.h>\n#include<WinSock2.h>\n\nint main()\n{\n\tWORD wVersionRequested;\n\tWSADATA wsdata;\n\n\twVersionRequested = MAKEWORD(1,1);\n\tint result = WSAStartup(wVersionRequested,&wsdata);\n\tif(result != 0)\n\t{\n\t\treturn 0;\n\t}\n\tif(LOBYTE(wsdata.wVersion) != 1 || HIBYTE(wsdata.wVersion) != 1)\n\t{\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\twhile(1){\n\tSOCKET connect_socket = socket(AF_INET,SOCK_STREAM,0);\n\tsockaddr_in sockad;\n\tsockad.sin_family = AF_INET;\n\tsockad.sin_port = htons(6000);\n\tsockad.sin_addr.S_un.S_addr = inet_addr(\"125.221.225.14\");\n\t//connect(connect_socket,(sockaddr*)&sockad,sizeof(SOCKADDR));\n\tconnect(connect_socket,(sockaddr*)&sockad,sizeof(SOCKADDR));\n\tchar sendbuff[1000] = {0};\n\tchar recivebuff[1000] = {0};\n\trecv(connect_socket,recivebuff,sizeof(recivebuff),0);\n\tprintf(\"%s\\n\",recivebuff);\n\tprintf(\"input your message: \");\n\tgets(sendbuff);\n\tsend(connect_socket,sendbuff,sizeof(sendbuff)+1,0);\n\tclosesocket(connect_socket);\n\t}\n\tWSACleanup();\n\treturn 0;\n}\n```\n\n<br>\n## 基于UDP协议的Socket程序\n<br>\n```c\n//客户端\n#include<stdio.h>\n#include<WinSock2.h>\n\nint main()\n{\n\tWORD wVersionRequested = MAKEWORD(1,1);\n\tWSAData wsdata;\n\tint flag = WSAStartup(wVersionRequested,&wsdata);\n\tif(flag != 0)\n\t\treturn 0;\n\tif(HIBYTE(wsdata.wVersion) != 1 || LOBYTE(wsdata.wVersion) != 1)\n\t{\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\n\tSOCKET client_socket = socket(AF_INET,SOCK_DGRAM,0);\n\tchar sendbuff[1000] = {0};\n\tsockaddr_in clientadd;\n\tclientadd.sin_family = AF_INET;\n\tclientadd.sin_port=htons(6000);\n\tclientadd.sin_addr.S_un.S_addr = inet_addr(\"125.221.225.14\");\n\tgets(sendbuff);\n\tsendto(client_socket,sendbuff,sizeof(sendbuff),0,(SOCKADDR*)&clientadd,sizeof(sockaddr_in));\n\tclosesocket(client_socket);\n\tWSACleanup();\n\treturn 0;\n}\n\n\n//服务器端\n/*\n名称：基于UDP协议的服务端程序\n作者： fengzixu\n时间: 2014/11/25\n简介：\n基于UDP和TCP两个协议的不同版本，大致的框架都是相同的，只是有几处细节不同。\n首先，基于TCP协议的服务端，需要两个套接字，一个用来绑定端口并且监听，一个用来建立连接。\n但是UDP协议中不需要监听和建立连接，绑定端口之后直接就可以通信，且从始至终只用一个套接字(在创建套接字的时候，TCP和UDP的类型是不一样的)\n其次，就是接受信息的API不同。TCP是recv而UDP是recvfrom\n*/\n\n\n#include<stdio.h>\n#include<WinSock2.h>\n\nint main()\n{\n\tWORD wVersionRequested = MAKEWORD(1,1);\n\tWSAData wsdata;\n\tint flag = WSAStartup(wVersionRequested,&wsdata);\n\tif(flag != 0)\n\t\treturn 0;\n\tif(HIBYTE(wsdata.wVersion) != 1 || LOBYTE(wsdata.wVersion) != 1)\n\t{\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\n\tSOCKET server_socket = socket(AF_INET,SOCK_DGRAM,0);\n\tsockaddr_in sockadd;\n\tsockadd.sin_family = AF_INET;\n\tsockadd.sin_port = htons(6000);\n\tsockadd.sin_addr.S_un.S_addr = htonl(INADDR_ANY);\n\n\tbind(server_socket, (SOCKADDR*)&sockadd,sizeof(SOCKADDR));\n\n\tchar recivebuff[1000] = {0};\n\tsockaddr_in clientaddr;\n\tint len = sizeof(clientaddr);\n\trecvfrom(server_socket,recivebuff,sizeof(recivebuff),0,(SOCKADDR*)&clientaddr,&len);\n\tprintf(\"%s\\n\",recivebuff);\n\tclosesocket(server_socket);\n\tWSACleanup();\n\treturn 0;\n}\n```\n<br>\n## 基于UDP协议的网络聊天程序\n\n### [源码，戳我](https://github.com/fengzixu/SocketTestPrograme/tree/master/UDPSocketTalkPrograme)\n\n\n<br>\n\n\n\n\n## 所有程序的源码\n### [Click it](https://github.com/fengzixu/SocketTestPrograme)","slug":"初探Windows网络编程","updated":1419898404000,"excerpt":"","_id":"y07r9zu3zyje911n","comments":true,"layout":"post","photos":[],"link":""},{"title":"重读CSAPP（第一章）","categories":["vui64jezcwp8fefa"],"date":1415797249000,"tags":["8u5k1qrjxmxqoj4q","3deavz2yda18qn81","uuyyus036pzw6j46"],"description":"对操作系统基本概念和知识的总结","content":"<blockquote>\n<p><strong>写在前面的话</strong>:<br>前几天在知乎提了一个问题，然后把自己的博客贴上去了。收到了很多批评和理解。<br>自己也觉得我学习的方式确实有问题，所以，现在正在努力的改正，改变过去。<br>我想，一个人有错是难免的，但是我想，我只要有一个好的态度，<br>嗯，然后有一个勇于改正自己的心就好了。我相信我能变好的。这次再写和读书有关的文章，<br>不会在像以前一样有点抄书的样子了，我尽量写一些自己的理解，以及对自己度过内容的总结。有不足指出也希望大家能够给我指出来。当然，不要太凶（`(<em>∩_∩</em>)′）。</p>\n</blockquote>\n<p><br></p>\n<p>CSAPP是一本我觉得让你能够构建一个计算机知识体系的书，这本书是我男神推荐我读的，之前读了前三章，因为一些事耽搁就没在继续读了，但是，OS真的是我喜欢的东西，所以，这次希望自己一鼓作气，读完它。<br>并且这本书也是CMU的经典教材，最宝贵的我觉得还是这本书自带的project，确实很珍贵，希望有看这本书的朋友一定把这几个project一定都做了。</p>\n<p>第一章主要还是从笔者的角度带我们预览或者说了解了一些计算机中的一些软硬件的知识，并且也介绍了，操作系统其实就是计算机中的软硬件结合部分，它相当于一座桥梁，能够让软件和硬件这两大家族能够进行良好的交流。</p>\n<p>以一个c语言的程序为例，展开来讲。书中像我们说明了，系统中所有的信息都是通过一串比特流来表示的，也就是01串，当然，有时候我们可能会重复用到一个同样的01串，但是，<br>计算机会根据上下文，也就是说程序执行的具体环境吧（我是这么理解的），来解释这些01串，以完成我们想要表示的多种信息。</p>\n<p>一个hello.c的源程序本身是一个文本文件，里面存储了我们写好的代码。因为这种高级语言的代码是为了方便我们能够看懂的，但是计算机的底层不一定明白。<br>计算机的高级语言有很多种，但是低级语言，也就是通用语言，通常被称为是汇编语言。汇编语言是更接近计算机底层的一种语言，因为组成计算机的硬件的结构大体相同，所以，<br>这种低级语言可以算作是计算机的通用语言，无论我们用c，Java，c#还是其他的一些编程语言来写程序，最终交给计算机执行的时候，都要转化成相应的低级机器语言指令。</p>\n<p>当我们在IDE中写了一个打印helloworld的程序的时候，通过编译器的编译，连接，最后生成一个exe文件能够运行。那么这之中到底经历了什么变化？</p>\n<p><br></p>\n<h2 id=\"一个C语言程序的旅程\">一个C语言程序的旅程</h2>\n<p>hello.c——-&gt;hello.i(预处理器#inlcude)———-&gt;hello.s(编译器翻译成汇编语言程序)———-&gt;hello.o(汇编器将汇编程序翻译成低级机器指令，此时文件内容是2进制的)————-&gt;hello（通过连接器将一些库函数进行连接得到可执行文件）</p>\n<p>上述过程基本上就是一个C语言程序从有到无的变换，括号中的解释都是大致的举了一个例子或者说是我自己的理解，帮助大家认识每一步都做了什么。</p>\n<p>之后的篇幅，大致介绍了计算机硬件组成。主要有一些几点，总结一下，加深印象：</p>\n<ul>\n<li>总线：计算机内部的传输通道，连接的计算机中的硬件，为他们传输信息</li>\n<li>I/O设备：算是计算机中比较大的一块了，感觉计算机中运行速度也主要在这里做了很多优化。关于这里有一个我觉得比较重要的概念，以前没有分清：</li>\n<li>每一个I/O设备都通过一个控制器和一个适配器与总线相连。控制器就是一个芯片组，而适配器是一个插在主板插槽上面的卡，比如网卡，显卡。</li>\n<li>处理器：也就是我们常说的CPU，里面的PC计数器，也就是程序计数器总是会指向计算机要执行的下一条指令的地址。</li>\n</ul>\n<p><br></p>\n<h2 id=\"CPU_主存_硬盘的关系\">CPU 主存 硬盘的关系</h2>\n<p>其实，学过操作系统的人都明白，计算机的运算速度还是很快的，但是这个运算速度仅仅指的是CPU处理指令的速度。但是有的时候为什么计算机会出现卡的现象呢，是因为计算机在完成一个任务的时候，把绝大部分时间都放在了信息的I/O上面。也就是说，CPU要处理的数据只能够从寄存器中获取，寄存器的信息要从内存当中获取，如果内存当中没有就要从硬盘先调入到内存，然后再把数据发送给CPU。由于这样做的速度 一直比较慢，并且根据操作系统的<strong>局部性原理</strong>，我运行一条指令，那么存储在他周围的指令我很可能也会用到，我上一次用到的，我可能很快还会用到。根据这种特点，我们就设计了空间小，速度快的高速缓存作为一个缓冲区。记录一下CPU近期内使用频率较高的数据，以及附近的数据，把他们存储到高速缓存中。因为告诉缓存还有CPU内部的寄存器都有空间小但是速度快的特点，所以大部分的数据和指令可能都不用从内存中找了，直接在上面两个存储器中就可以找到。<br><br></p>\n<h2 id=\"存储等级\">存储等级</h2>\n<p>计算机当中需求不同，设备自然也不同。要求速度快，当然需要告诉缓存这样的存储器，需要容量大，那么就需要像硬盘这种存储器。存储器根据存取速度和容量大小划分等级，上一层的存储器是下一层存储器的高速缓存。<br><br></p>\n<h2 id=\"进程\">进程</h2>\n<p>进程简而言之就是运行当中的程序。对单处理器系统而言，可以运行多个进程，通过进程的切换让人们造成一种计算机可以同时运行多个任务。其实这种假象是靠频繁的进程切换实现的。多线程的出现也提供了进程的工作效率。<br><br></p>\n<h2 id=\"内存的结构\">内存的结构</h2>\n<p>计算机的内存分为系统区和用户区，系统区是专门留给操作系统的，他人不得插手。对于每个进程来说，他们都会误以为自己是独占内存当中的用户区的，这就是计算机当中的虚拟存储器，他给了每一个进程一个虚拟的地址空间。内存从高到低，地址依次降低。</p>\n<p>用户区中比较常见的固定 区域有堆，栈，共享区域，代码数据区域。每一个位置都有自己特定的作用，其余的都是自由空间。</p>\n<p><br></p>\n<h2 id=\"总结\">总结</h2>\n<p>基本来说，第一章就是介绍了一些基础的知识，对操作系统的一些概念做了解释。感觉重点的只有一个：就是要理解并且记住，计算机当中抽象是非常重要的。常用的计算机当中的抽象有三个：</p>\n<ol>\n<li>文件是对I/O的抽象，这点用过linux的人都知道</li>\n<li>虚拟存储器是对内存和硬盘的抽象（学过OS的人都知道，这里不好展开解释）</li>\n<li>进程是对运行当中程序的抽象</li>\n</ol>\n<p>抽象，我的理解就是让东西变得更加傻瓜和友好，最大限度的屏蔽掉所有的实现细节，让用户能够更容易的使用。比如，本来运行当中的程序是看不到的（我指的是计算机内部中），但是通过抽象成进程，我们就能够对它有一个更加清晰的认识。所以说，抽象有的时候能帮我们理解一些复杂的东西。</p>\n","source":"_posts/重读CSAPP（第一章）.md","raw":"title: 重读CSAPP（第一章）\ncategories: CSAPP\ndate: 2014-11-12 21:00:49\ntags: [os, csapp, 读书笔记]\ndescription: 对操作系统基本概念和知识的总结\n---\n\n>**写在前面的话**:\n前几天在知乎提了一个问题，然后把自己的博客贴上去了。收到了很多批评和理解。\n自己也觉得我学习的方式确实有问题，所以，现在正在努力的改正，改变过去。\n我想，一个人有错是难免的，但是我想，我只要有一个好的态度，\n嗯，然后有一个勇于改正自己的心就好了。我相信我能变好的。这次再写和读书有关的文章，\n不会在像以前一样有点抄书的样子了，我尽量写一些自己的理解，以及对自己度过内容的总结。有不足指出也希望大家能够给我指出来。当然，不要太凶（`(*∩_∩*)′）。\n>\n\n\n<br/>\n\n\n\n\n\nCSAPP是一本我觉得让你能够构建一个计算机知识体系的书，这本书是我男神推荐我读的，之前读了前三章，因为一些事耽搁就没在继续读了，但是，OS真的是我喜欢的东西，所以，这次希望自己一鼓作气，读完它。\n并且这本书也是CMU的经典教材，最宝贵的我觉得还是这本书自带的project，确实很珍贵，希望有看这本书的朋友一定把这几个project一定都做了。\n\n第一章主要还是从笔者的角度带我们预览或者说了解了一些计算机中的一些软硬件的知识，并且也介绍了，操作系统其实就是计算机中的软硬件结合部分，它相当于一座桥梁，能够让软件和硬件这两大家族能够进行良好的交流。\n\n以一个c语言的程序为例，展开来讲。书中像我们说明了，系统中所有的信息都是通过一串比特流来表示的，也就是01串，当然，有时候我们可能会重复用到一个同样的01串，但是，\n计算机会根据上下文，也就是说程序执行的具体环境吧（我是这么理解的），来解释这些01串，以完成我们想要表示的多种信息。\n\n一个hello.c的源程序本身是一个文本文件，里面存储了我们写好的代码。因为这种高级语言的代码是为了方便我们能够看懂的，但是计算机的底层不一定明白。\n计算机的高级语言有很多种，但是低级语言，也就是通用语言，通常被称为是汇编语言。汇编语言是更接近计算机底层的一种语言，因为组成计算机的硬件的结构大体相同，所以，\n这种低级语言可以算作是计算机的通用语言，无论我们用c，Java，c#还是其他的一些编程语言来写程序，最终交给计算机执行的时候，都要转化成相应的低级机器语言指令。\n\n当我们在IDE中写了一个打印helloworld的程序的时候，通过编译器的编译，连接，最后生成一个exe文件能够运行。那么这之中到底经历了什么变化？\n\n<br/>\n## 一个C语言程序的旅程\n\nhello.c----->hello.i(预处理器#inlcude)------->hello.s(编译器翻译成汇编语言程序)------->hello.o(汇编器将汇编程序翻译成低级机器指令，此时文件内容是2进制的)--------->hello（通过连接器将一些库函数进行连接得到可执行文件）\n\n\n上述过程基本上就是一个C语言程序从有到无的变换，括号中的解释都是大致的举了一个例子或者说是我自己的理解，帮助大家认识每一步都做了什么。\n\n\n之后的篇幅，大致介绍了计算机硬件组成。主要有一些几点，总结一下，加深印象：\n- 总线：计算机内部的传输通道，连接的计算机中的硬件，为他们传输信息\n- I/O设备：算是计算机中比较大的一块了，感觉计算机中运行速度也主要在这里做了很多优化。关于这里有一个我觉得比较重要的概念，以前没有分清：\n- 每一个I/O设备都通过一个控制器和一个适配器与总线相连。控制器就是一个芯片组，而适配器是一个插在主板插槽上面的卡，比如网卡，显卡。\n- 处理器：也就是我们常说的CPU，里面的PC计数器，也就是程序计数器总是会指向计算机要执行的下一条指令的地址。\n\n<br/>\n## CPU 主存 硬盘的关系\n其实，学过操作系统的人都明白，计算机的运算速度还是很快的，但是这个运算速度仅仅指的是CPU处理指令的速度。但是有的时候为什么计算机会出现卡的现象呢，是因为计算机在完成一个任务的时候，把绝大部分时间都放在了信息的I/O上面。也就是说，CPU要处理的数据只能够从寄存器中获取，寄存器的信息要从内存当中获取，如果内存当中没有就要从硬盘先调入到内存，然后再把数据发送给CPU。由于这样做的速度 一直比较慢，并且根据操作系统的**局部性原理**，我运行一条指令，那么存储在他周围的指令我很可能也会用到，我上一次用到的，我可能很快还会用到。根据这种特点，我们就设计了空间小，速度快的高速缓存作为一个缓冲区。记录一下CPU近期内使用频率较高的数据，以及附近的数据，把他们存储到高速缓存中。因为告诉缓存还有CPU内部的寄存器都有空间小但是速度快的特点，所以大部分的数据和指令可能都不用从内存中找了，直接在上面两个存储器中就可以找到。\n<br/>\n## 存储等级\n计算机当中需求不同，设备自然也不同。要求速度快，当然需要告诉缓存这样的存储器，需要容量大，那么就需要像硬盘这种存储器。存储器根据存取速度和容量大小划分等级，上一层的存储器是下一层存储器的高速缓存。\n<br/>\n## 进程\n进程简而言之就是运行当中的程序。对单处理器系统而言，可以运行多个进程，通过进程的切换让人们造成一种计算机可以同时运行多个任务。其实这种假象是靠频繁的进程切换实现的。多线程的出现也提供了进程的工作效率。\n<br/>\n## 内存的结构\n计算机的内存分为系统区和用户区，系统区是专门留给操作系统的，他人不得插手。对于每个进程来说，他们都会误以为自己是独占内存当中的用户区的，这就是计算机当中的虚拟存储器，他给了每一个进程一个虚拟的地址空间。内存从高到低，地址依次降低。\n\n用户区中比较常见的固定 区域有堆，栈，共享区域，代码数据区域。每一个位置都有自己特定的作用，其余的都是自由空间。\n\n<br/>\n## 总结\n基本来说，第一章就是介绍了一些基础的知识，对操作系统的一些概念做了解释。感觉重点的只有一个：就是要理解并且记住，计算机当中抽象是非常重要的。常用的计算机当中的抽象有三个：\n1. 文件是对I/O的抽象，这点用过linux的人都知道\n2. 虚拟存储器是对内存和硬盘的抽象（学过OS的人都知道，这里不好展开解释）\n3. 进程是对运行当中程序的抽象\n\n抽象，我的理解就是让东西变得更加傻瓜和友好，最大限度的屏蔽掉所有的实现细节，让用户能够更容易的使用。比如，本来运行当中的程序是看不到的（我指的是计算机内部中），但是通过抽象成进程，我们就能够对它有一个更加清晰的认识。所以说，抽象有的时候能帮我们理解一些复杂的东西。\n\n\n\n\n\n\n","slug":"重读CSAPP（第一章）","updated":1419898404000,"excerpt":"","_id":"4mq396sz07h2qgmp","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"读书笔记","_id":"uuyyus036pzw6j46","posts":["dvw216okq8beg7sn","sairt3q2rslnr26m","yzt8daaychd8puyu","v42oi49bn9bbqzi5","0lgbbh81pebd64e5","4mq396sz07h2qgmp"]},{"name":"os","_id":"8u5k1qrjxmxqoj4q","posts":["yzt8daaychd8puyu","87y8rz2bi7woe2x4","v42oi49bn9bbqzi5","0lgbbh81pebd64e5","4mq396sz07h2qgmp"]},{"name":"计算机网络","_id":"pfh4hkh1eqdtx3gu","posts":["yzt8daaychd8puyu"]},{"name":"基础知识","_id":"7bhe1xim8o34gpgy","posts":["yzt8daaychd8puyu"]},{"name":"Life","_id":"24y8g97kma62y7zc","posts":["00qaobvpvh6on9pr"]},{"name":"csapp","_id":"3deavz2yda18qn81","posts":["0lgbbh81pebd64e5","4mq396sz07h2qgmp"]},{"name":"Windows socket","_id":"rih0ekzximdfg7de","posts":["y07r9zu3zyje911n"]}]}